---
title: "Comparison"
author: "Kacper Kaszuba"
date: "`r Sys.Date()`"
runtime: shiny
output: 
    html_document:
        toc: true
        toc_float: 
            collapsed: false
        code_download: true
fontsize: 14pt
css: document_style.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, fig.align = "center", fig.keep = "all", echo = FALSE)

shift_dist_impute <- function(df, width = 0.5, downshift = 1, seed = 7694) {
    # df = data frame containing filtered data
    # Assumes missing data (in df) follows a narrowed and downshifted normal distribution
    
    #Seed for reproducibility (useful for later analysis)
    set.seed(seed)
    
    # Create new column indicating whether the values are imputed 
    # df$imputed = !is.finite(df$LFQvalue)
    
    # Imputation
    temp <- df
    temp[!is.finite(temp)] <- NA #make sure all non-finite values are really NA
    temp.sd <- width * sd(temp, na.rm = TRUE) #shrink sd width
    temp.mean <- mean(temp, na.rm = TRUE) - 
        downshift * sd(temp, na.rm = TRUE) #shift mean of imputed values
    n.missing <- sum(is.na(temp))
    #replace NA with values from the new distribution
    temp[is.na(temp)] <- rnorm(n.missing, mean = temp.mean, sd = temp.sd) 
    
    df <- temp
    
    return(df)
}

imputation <- function(rf_model, df_to_model, df_ml) {
    
    mar_prots <- which(df_ml$missingness == "MAR")
    mnar_prots_long <- which(df_ml$missingness == "MNAR")
    
    mar_impute <- predict(rf_model, df_to_model[mar_prots,-ncol(df_to_model)])$predictions
    
    lfq_wide <- df_ml |>
        dplyr::select(celltype, rep, LFQvalue) |>
        dplyr::mutate(batch = paste(celltype, rep, sep=".")) |>
        dplyr::select(batch, LFQvalue) |>
        tidyr::pivot_wider(id_cols = dplyr::everything(), names_from = batch, values_from = LFQvalue, values_fn = list) |>
        tidyr::unnest(c("KO.22", "KO.23", "KO.24", "WT.22", "WT.23", "WT.24")) |>
        dplyr::mutate(missingness = df_ml$missingness[seq(1,nrow(df_ml), by=6)])
    
    mnar_prots <- which(lfq_wide$missingness == "MNAR")
    
    lfq.KO <- lfq_wide |> dplyr::select(dplyr::contains("KO"))
    lfq.KO <- log2(lfq.KO)
    lfq.WT <- lfq_wide |> dplyr::select(dplyr::contains("WT"))
    lfq.WT <- log2(lfq.WT)
    
    mnar_impute.KO <- apply(lfq.KO, 2, shift_dist_impute) # function wrote by Mateusz
    mnar_impute.WT <- apply(lfq.WT, 2, shift_dist_impute) # function wrote by Mateusz

    lfq.KO[mnar_prots,] <- mnar_impute.KO[mnar_prots,]
    lfq.WT[mnar_prots,] <- mnar_impute.WT[mnar_prots,]
    
    lfq_imp <- cbind.data.frame(lfq.KO, lfq.WT) |>
        tidyr::pivot_longer(cols = dplyr::everything(), names_to = "batch", values_to = "LFQ")
    
    df_final <- df_ml
    
    df_final$LFQvalue <- lfq_imp$LFQ
    
    df_final$LFQvalue[mar_prots] <- log2(mar_impute)
    
    df_final <- df_final |>
        dplyr::select(celltype, rep, missingness, LFQvalue) |>
        dplyr::mutate(batch = paste(celltype, rep, sep=".")) |>
        dplyr::select(batch, LFQvalue) |>
        tidyr::pivot_wider(id_cols = everything(), names_from = batch, values_from = LFQvalue, values_fn = list) |>
        tidyr::unnest(c("KO.22", "KO.23", "KO.24", "WT.22", "WT.23", "WT.24")) |>
        dplyr::mutate(missingness = df_ml$missingness[seq(1,nrow(df_ml), by=6)])
    
    return(df_final)
}

show_cv_table <- function(df) {
    DT::datatable(df, rownames = FALSE, 
              options=list(searching=FALSE, paging=FALSE, info=FALSE)) |>
    DT::formatStyle(columns = c("mean_KO", "mean_WT", "median_KO", "median_WT"), 
                    background = DT::styleInterval(c(15, 25), c("white","lightgreen", "white"))) |>
    DT::formatStyle(columns = "method", fontWeight = "bold")
}

assign_missing <- function(protein.ids, condition, lfq_intensity) {
    # verification of the fxn assumptions
    if (!is.factor(condition)) {rlang::abort("The condition are not factor!")}

    # occurences of protein IDs per condition
    occur <- dplyr::tibble(protein.ids) |>
        dplyr::group_by(protein.ids) |>
        dplyr::summarise(len = length(protein.ids)) |>
        dplyr::distinct(len)

    # occurences of condition
    occur_per_cond <- dplyr::tibble(protein.ids, condition) |>
        dplyr::group_by(protein.ids, condition) |>
        dplyr::summarise(len = length(protein.ids))
    occur_per_cond <- unique(occur_per_cond$len)

    if (length(protein.ids)/occur != length(unique(protein.ids))) {rlang::abort("The protein IDs are not unique!")}
    if (!is.numeric(lfq_intensity)) {rlang::abort("The lfq intensities are not numeric!")}

    df <- data.frame("prot.IDs"=protein.ids, "condition"=condition, "lfq"=lfq_intensity)

    # Calculating number of missing values for each protein for each condition
    number_missing1 <- df |>
        dplyr::group_by(prot.IDs, condition) |>
        dplyr::summarise(no_NAs = sum(is.na(lfq)))

    missingness_per_cond <- purrr::map(number_missing1$no_NAs, function(no) {
            if (no == occur_per_cond) {
              rep("all_NA", occur_per_cond)
            } else if (no == occur_per_cond-1) {
              rep("MNAR", occur_per_cond)
            } else if (no < occur_per_cond-1 & no != 0) {
              rep("MAR", occur_per_cond)
            } else if (no == 0){
              rep("complete", occur_per_cond)
            }
        })
    missingness_per_cond <- data.frame(do.call(c,missingness_per_cond))
    
    # Calculating number of missing values for each protein
    number_missing2 <- df |>
        dplyr::group_by(prot.IDs) |>
        dplyr::summarise(no_NAs = sum(is.na(lfq)))
    
    missingness_per_prot <- purrr::map(number_missing2$no_NAs, function(no) {
            if (no == occur) {
              rep("all_NA", occur)
            }else if (no == occur-1) {
              rep("MNAR", occur)
            } else if (no < occur-1 & no != 0) {
              rep("MAR", occur)
            } else if (no == 0){
              rep("complete", occur)
            }
        }) 
    missingness_per_prot <- data.frame(do.call(c, missingness_per_prot))

    prot.id.miss <- purrr::map(unique(number_missing2$prot.IDs), function(id) rep(id, occur))
    prot.id.miss <- data.frame(do.call(c,prot.id.miss))

    df_miss <- data.frame(prot.id.miss, missingness_per_cond, missingness_per_prot)
    colnames(df_miss) <- c("prot.IDs", "missingness_per_cond", "missingness_per_prot")

    missingness_per_cond <- lapply(unique(protein.ids), function(id) df_miss[which(df_miss$prot.IDs == id),"missingness_per_cond"])
    df$missingness_per_cond <- do.call(c,missingness_per_cond)
    
    missingness_per_prot <- lapply(unique(protein.ids), function(id) df_miss[which(df_miss$prot.IDs == id),"missingness_per_prot"])
    df$missingness_per_prot <- do.call(c,missingness_per_prot)
    
    # Testing new missing assigning
    missingness_final <- df |>
        dplyr::select(condition, missingness_per_cond) |>
        tidyr::pivot_wider(id_cols=everything(), names_from = "condition", 
                           values_from="missingness_per_cond", values_fn = list) |> 
        tidyr::unnest(cols = everything())
    
    cond_id <- seq(1,nrow(missingness_final), by=3)
    missingness_final <- missingness_final[cond_id,]
    
    missingness_final2 <- purrr::map(1:nrow(missingness_final), function(i) {
        if (all(missingness_final[i,] == "all_NA")) {
            rep(NA, occur)
        } else if ((missingness_final[i,1] == "complete" & missingness_final[i,2] == "all_NA") | (missingness_final[i,2] == "complete" & missingness_final[i,1] == "all_NA")) {
            rep("MNAR", occur)
        } else if ((missingness_final[i,1] == "MAR" & missingness_final[i,2] == "MNAR") | (missingness_final[i,2] == "MAR" & missingness_final[i,1] == "MNAR")) {
            rep(NA, occur)
        } else if (all(missingness_final[i,] == "MAR")) {
            rep("MAR", occur)
        } else if (all(missingness_final[i,] == "MNAR")) {
            rep(NA, occur)
        } else if (all(missingness_final[i,] == "complete")) {
            rep("complete", occur)
        } else if ((missingness_final[i,1] == "complete" & missingness_final[i,2] =="MNAR") | (missingness_final[i,2] == "complete" & missingness_final[i,1] =="MNAR")) {
            rep("MNAR", occur)
        } else if ((missingness_final[i,1] == "complete" & missingness_final[i,2] =="MAR") | (missingness_final[i,2] == "complete" & missingness_final[i,1] =="MAR")) {
            rep(NA, occur)  # zostawić NA i policzyć p-value dla mniejszej ilości danych
        } else {
            rep(NA, occur)
        }
    })

    df$missingness = do.call(c,missingness_final2)
    
    # return
    ret_list <- list(df = df, missingness_per_cond=df$missingness_per_cond,
                     missingness_per_prot = df$missingness_per_prot,
                     missingness = df$missingness,
                     test = missingness_final)
}

ttest <- function(df, grp1, grp2){ 
  x = df[grp1]
  y = df[grp2]
  x = as.numeric((x))
  y = as.numeric((y))
  results = t.test(x,y, 
                   alternative = "two.sided", #one-sided: "greater" is x > y
                   paired = F,
                   na.action=na.omit)
  results$p.value
}

plothist <- function(df, title="", plot.title.and.legend=TRUE) {
    if (!is.data.frame(df)) { df <- as.data.frame(df)}
    
    # Assuming LFQ_KO is our data frame with at least 3 columns
    # Reshape the data to a long format
    df <- df |>
        pivot_longer(cols = 1:ncol(df), names_to = "Rep", values_to = "LFQValue")
    
    # Plot all histograms on the same plot using ggplot
    if (plot.title.and.legend) {
        ret_plot <- ggplot(df, aes(x = LFQValue, fill = Rep)) +
            geom_histogram(alpha = 0.4, position = "identity", bins = 30) +
            labs(title = paste(title), x = "Values", y = "Frequency") +
            theme(legend.title = element_blank())
    } else {
        ret_plot <- ggplot(df, aes(x = LFQValue, fill = Rep)) +
            geom_histogram(alpha = 0.4, position = "identity", bins = 30) +
            labs(x = "Values", y = "Frequency") +
            theme(legend.title = element_blank(), legend.position = "none")
    }
    return(ret_plot)
}

plotoneviolin <- function(object, title="") {
    object <- as.data.frame(object) |>
        pivot_longer(everything(), names_to = "Sample", values_to = "LFQ_CV")
    
    ggplot(data=object, aes(x=Sample, y=LFQ_CV, fill=Sample))+
        geom_boxplot(width=0.2, na.rm = TRUE)+
        geom_violin(alpha=0.4, na.rm = TRUE)+
        labs(title=title,x=NULL,y="LFQ CV[%]")+
        theme(legend.position = "none",
              panel.background = element_rect(fill="white", colour = "grey"),
              panel.grid = element_line(colour = "grey"))
}

library(ggplot2)
library(ggpubr)
library(dplyr)
library(tidyr)
library(vsn)
library(protti)
library(plotly)
source("EigenMS/EigenMS/EigenMS.R")

writeLines("table {
  width: 100%;
  border-collapse: collapse;
}
th, td {
  width: 14.28%; /* Distribute width equally (100% / 7 columns) */
  border: 1px #f2f2f2;
  text-align: center; /* Center the text */
  padding: 8px;
}
th {
  background-color: #f2f2f2;
  border: 0px;
}
body {
    text-align: justify
}", con = "document_style.css")
```

```{r load data}
# load raw data
protein.groups <- readr::read_tsv("./data/proteinGroups.txt", show_col_types = FALSE)

protein.groups <- protein.groups |> filter(is.na(`Only identified by site`),
                         is.na(Reverse),
                         is.na(`Potential contaminant`))

lfq <- protein.groups |>
    dplyr::select(dplyr::starts_with("LFQ Intensity") & (ends_with("22") | ends_with("23") | ends_with("24")) & dplyr::contains("MITOS"))

colnames(lfq) <- gsub("_MITOS_", ".", gsub("LFQ intensity ", "", colnames(lfq)))
lfq[lfq == 0] <- NA
lfq <- log2(lfq)
```

```{r data to ML models}
# extracting columns to machine learning models
df_ml <- protein.groups |>
    dplyr::select(`Number of proteins`, Peptides, `Sequence coverage [%]`, `Sequence length`, 
                  `Mol. weight [kDa]`, `Q-value`, Score, `MS/MS count`, 
                  dplyr::starts_with("LFQ Intensity") & (ends_with("22") | ends_with("23") | ends_with("24")) & dplyr::contains("MITOS"))

# changing the colnames
colnames(df_ml)[9:14] <- gsub("LFQ intensity ", "", colnames(df_ml)[9:14])

# making longer data frame with one column containing all LFQ values
df_ml <- df_ml |>
    dplyr::mutate(prot.id = paste("prot",1:nrow(df_ml),sep="_")) |>
    tidyr::pivot_longer(9:14, names_to = "Sample", values_to = "LFQvalue") |>
    tidyr::separate(col=Sample, into=c("celltype","sampletype","rep"), sep = "_", remove = FALSE) |>
    dplyr::mutate(celltype = as.factor(celltype), sampletype = as.factor(sampletype),
                  rep = as.factor(rep))

# changing values with 0 to NA
df_ml$LFQvalue[df_ml$LFQvalue==0] <- NA

missingness <- assign_missing(df_ml$prot.id, df_ml$celltype, df_ml$LFQvalue)
df_ml$missingness_per_cond <- missingness$missingness_per_cond
df_ml$missingness_per_prot <- missingness$missingness_per_prot
df_ml$missingness <- missingness$missingness

df_ml$missingness[is.na(df_ml$missingness)] <- "all_NA"

# removing blank spaces and all separators from colnames
colnames(df_ml)[1:8] <- c("no.proteins", "peptides","seq.coverage","seq.len",
                          "mol.weight.kDa","q.value","score","ms.count")


# Remove unnecessary columns and reordering columns
df_ml.to.models <- df_ml |>
    dplyr::select(-prot.id, -Sample, -sampletype) |> dplyr::select(1:10, 12:14, 11) |>
    dplyr::mutate(missingness_per_prot = as.numeric(as.factor(missingness_per_prot)),
                  missingness_per_cond = as.numeric(as.factor(missingness_per_cond)),
                  celltype = as.numeric(celltype),
                  rep = as.numeric(rep),
                  missingness = as.numeric(as.factor(missingness)))

df_ml <- df_ml |>
    dplyr::select(-prot.id, -Sample) |> dplyr::select(1:11, 13:15, 12) |>
    dplyr::mutate(missingness_per_prot = as.factor(missingness_per_prot),
                  missingness_per_cond = as.factor(missingness_per_cond),
                  missingness = as.factor(missingness))
```

```{r protti}
df_to_protti <- protein.groups |>
    dplyr::select(`Protein IDs`, `Peptide sequences`, 
           contains("LFQ intensity") & contains("MITOS") & (ends_with("22") | ends_with("23") | ends_with("24"))) |>
    dplyr::mutate(`Protein IDs`= paste("prot_", 1:nrow(protein.groups), sep="")) |>
    tidyr::pivot_longer(3:8, names_to = "Sample", values_to = "Intensity")|>
    dplyr::mutate(Sample = gsub("LFQ intensity ", "", Sample)) |>
    dplyr::mutate(Sample = gsub("_MITOS_", "_", Sample)) |>
    tidyr::separate(col =  Sample, into = c("celltype","rep"), sep = "_", remove = F) |>
    dplyr::mutate(Condition = ifelse(celltype == "KO", "treated", "control"),
           Intensity = ifelse(Intensity == 0, NA, log2(Intensity))) |> 
    dplyr::select(Sample, `Protein IDs`, `Peptide sequences`, Condition, Intensity) 
```

```{r ludovic}
# assign missingness with protti fxn
data_missing <- df_to_protti |>
    assign_missingness(sample=Sample,
                       condition = Condition,
                       grouping = `Protein IDs`,
                       intensity = Intensity,
                       ref_condition = "all")

temp <- df_ml$missingness
temp[which(temp == "all_NA")] <- NA
data_missing$missingness <- temp

# impute data with protti fxn using ludovic method
imputed_ludovic <- impute(
    data_missing,
    sample = Sample,
    grouping = `Protein IDs`,
    intensity_log2 = Intensity,
    condition = Condition,
    comparison = comparison,
    missingness = missingness,
    method = "ludovic",
    skip_log2_transform_error = TRUE
)
rm(data_missing, temp)

# extracting KO and WT
imputed_ludovic <- imputed_ludovic |>
    dplyr::select(Sample, imputed_intensity, `Protein IDs`, missingness) |>
    tidyr::pivot_wider(id_cols = everything(), names_from = Sample, values_from = imputed_intensity)
```

# Number of Missing Values per Condition

```{r rows.to.keep}
tempKO <- apply(lfq[grep("KO", colnames(lfq))], 1, function(row) sum(is.na(row)))
tempWT <- apply(lfq[grep("WT", colnames(lfq))], 1, function(row) sum(is.na(row)))
temp <- cbind.data.frame(KO=tempKO, WT=tempWT)
temp$sum <- temp[,1] + temp[,2]

rows.to.keep <- which((temp[,1] == 3 & temp[,2] == 0) | (temp[,1] == 0 & temp[,2] == 3) |
                      (temp[,1] == 1 & temp[,2] == 0) | (temp[,1] == 0 & temp[,2] == 1) |
                      (temp[,1] == 0 & temp[,2] == 0) | (temp[,1] == 1 & temp[,2] == 1) |
                      (temp[,1] == 2 & temp[,2] == 0) | (temp[,1] == 0 & temp[,2] == 2))

temp <- temp |>
    pivot_longer(cols = 1:2, names_to = "cell", values_to = "no_miss") |>
    mutate(sum = as.factor(sum)) |>
    dplyr::group_by(cell, no_miss, sum) |>
    dplyr::summarise(count = n(), .groups = "drop")

ggplot(data = temp, aes(x = no_miss, y = count, fill=sum, color=cell)) +
    geom_bar(stat = "identity", position = position_dodge()) + 
    geom_text(aes(label = count), position = position_dodge(width = 0.9),
              vjust = -0.4, size = 3)+
    labs(title="Count of the number of missing values for cell type", 
         xlab="Number of Missing Values per Condition", fill="No. miss.\nper row")
```

```{r clean data}
# Raw Data
lfq <- lfq[rows.to.keep,]

# Extracting only MITOS data for knockout
LFQ_KO <- lfq |> select(contains("KO"))

# Extracting only MITOS data for wild type
LFQ_WT <- lfq |> select(contains("WT"))

# Ludovic
imputed_ludovic <- imputed_ludovic[rows.to.keep,]

# extracting KO and WT
LFQ_KO_ludovic <- imputed_ludovic |> dplyr::select(contains("KO"))
LFQ_WT_ludovic <- imputed_ludovic |> dplyr::select(contains("WT"))

miss_type <-  data.frame(miss = as.character(imputed_ludovic$missingness),
                         protein.ids = protein.groups$`Protein IDs`[rows.to.keep])
miss_type[is.na(miss_type$miss),1] <- "one_NA"
```

# Distributions

## Ludovic

```{r distribution ludovic}
ggarrange(
    plothist(LFQ_KO, "", FALSE) + xlab("KO") + ggtitle("Non-Imputed"), 
    plothist(LFQ_WT, "", FALSE) + xlab("WT") + ggtitle(""),
    plothist(LFQ_KO_ludovic, "", FALSE) + xlab("KO") + ggtitle("Imputed - Ludovic"), 
    plothist(LFQ_WT_ludovic, "", FALSE) + xlab("WT") + ggtitle(""),
    nrow=2,ncol=2
)
```

# Transformations {.tabset}

## Raw Data

```{r skew raw}
skew <- data.frame(raw_data = moments::skewness(2^lfq,na.rm=T),
                   sqrt = moments::skewness(sqrt(2^lfq),na.rm=T),
                   log = moments::skewness(log(2^lfq),na.rm=T),
                   log10 = moments::skewness(log10(2^lfq),na.rm=T),
                   `frac` = moments::skewness(1/(2^lfq),na.rm=T))
DT::datatable(t(round(skew,4)), options=list(paging=F, info=F, searching=F)) |>
    DT::formatStyle(3, backgroundColor ="lightgreen")
```

## Ludovic

```{r skew ludovic}
skew_ludovic <- data.frame(raw_data = moments::skewness(2^imputed_ludovic[,3:8],na.rm=T),
                   sqrt = moments::skewness(sqrt(2^imputed_ludovic[,3:8]),na.rm=T),
                   log = moments::skewness(log(2^imputed_ludovic[,3:8]),na.rm=T),
                   log10 = moments::skewness(log10(2^imputed_ludovic[,3:8]),na.rm=T),
                   `frac` = moments::skewness(1/(2^imputed_ludovic[,3:8]),na.rm=T))
DT::datatable(t(round(skew_ludovic,4)), options=list(paging=F, info=F, searching=F)) |>
    DT::formatStyle(3, backgroundColor ="lightgreen")
```

# Normalization

## EigenMS

```{r eigen norm, fig.keep="none", results="hide"}
treatment = as.factor(c("KO", "KO", "KO", "WT", "WT", "WT"))

# Non-Imputed
prot.info <- data.frame(prot_ID = paste("prot_", 1:nrow(lfq), sep = "")) # add info about LFQ value
LFQ.eig1 <- eig_norm1(lfq, 
                      treatment = treatment, 
                      prot.info = prot.info)
# Performing eig normalization
LFQ.eig_norm <- eig_norm2(LFQ.eig1)

LFQ_KO.eigen <- LFQ.eig_norm$norm_m[,1:3] # Non-Imputed
eigen_raw_ids <- as.numeric(gsub("prot_", "", rownames(LFQ_KO.eigen)))
temp <- LFQ_KO.eigen
LFQ_KO.eigen <- as.matrix(lfq[,1:3])
LFQ_KO.eigen[eigen_raw_ids,] <- temp

LFQ_WT.eigen <- LFQ.eig_norm$norm_m[,4:6] # Non-Imputed
eigen_raw_ids <- as.numeric(gsub("prot_", "", rownames(LFQ_WT.eigen)))
temp <- LFQ_WT.eigen
LFQ_WT.eigen <- as.matrix(lfq[,4:6])
LFQ_WT.eigen[eigen_raw_ids,] <- temp

# Imputed ludovic
prot.info <- data.frame(imputed_ludovic$`Protein IDs`) # add info about LFQ value
LFQ_ludovic.eig1 <- eig_norm1(imputed_ludovic[,-c(1,2)],
                              treatment = treatment,
                              prot.info = prot.info)
# Performing eig normalization
LFQ_ludovic.eig_norm <- eig_norm2(LFQ_ludovic.eig1)

LFQ_KO_ludovic.eigen <- LFQ_ludovic.eig_norm$norm_m[,1:3] # Imputed ludovic
LFQ_WT_ludovic.eigen <- LFQ_ludovic.eig_norm$norm_m[,4:6] # Imputed ludovic
```

```{r plot dist eigen}
ggarrange(
    plothist(LFQ_KO.eigen, "", FALSE) + xlab("KO") + ggtitle("Non-Imputed"), 
    plothist(LFQ_WT.eigen, "", FALSE) + xlab("WT") + ggtitle(""),
    plothist(LFQ_KO_ludovic.eigen, "", FALSE) + xlab("KO") + ggtitle("Imputed - Ludovic"), 
    plothist(LFQ_WT_ludovic.eigen, "", FALSE) + xlab("WT") + ggtitle(""),
    nrow=2,ncol=2
)
```

# Statistics Metrics {.tabset}

## CV {.tabset}

### Non-Imputed

```{r CV1}
# fxn to calculate the CV coefficient
cv <- function (x) sd(x) / mean(x) * 100

# CV calculation for all normalization methods using non-imputed data
cv.before <- data.frame(KO=apply(2^LFQ_KO, 1, cv), WT=apply(2^LFQ_WT,1,cv))
cv.eig <- data.frame(KO=apply(2^LFQ_KO.eigen, 1, cv), WT=apply(2^LFQ_WT.eigen, 1, cv))

ggarrange(
    plotoneviolin(data.frame(
        Original = cv.before$KO,
        EigenMS = cv.eig$KO
        ), "LFQ CV [%] for KO Samples") + 
        ggplot2::geom_hline(yintercept = c(15,25), linetype=c(2,2), color=c("red","red"), alpha=c(0.7,0.7)),
    plotoneviolin(data.frame(
        Original = cv.before$WT,
        EigenMS = cv.eig$WT
        ), "LFQ CV [%] for WT Samples") + 
        ggplot2::geom_hline(yintercept = c(15,25), linetype=c(2,2), color=c("red","red"), alpha=c(0.7,0.7)),
    nrow=2,ncol=1
)
```

### Ludovic

```{r CV2, fig.width=10}
# CV calculation for all normalization methods with imputed data using ludovic
cv_ludovic.before <- data.frame(KO=apply(2^LFQ_KO_ludovic, 1, cv), WT=apply(2^LFQ_WT_ludovic,1,cv))

cv_ludovic.eig <- data.frame(KO=apply(2^LFQ_KO_ludovic.eigen, 1, cv), WT=apply(2^LFQ_WT_ludovic.eigen, 1, cv))

ggarrange(
    plotoneviolin(data.frame(
        Original = cv_ludovic.before$KO,
        EigenMS = cv_ludovic.eig$KO
        ), "LFQ CV [%] for KO Samples") + 
        ggplot2::geom_hline(yintercept = c(15,25), linetype=c(2,2), color=c("red","red"), alpha=c(0.7,0.7)),
    plotoneviolin(data.frame(
        Original = cv_ludovic.before$WT,
        EigenMS = cv_ludovic.eig$WT
        ), "LFQ CV [%] for WT Samples") + 
        ggplot2::geom_hline(yintercept = c(15,25), linetype=c(2,2), color=c("red","red"), alpha=c(0.7,0.7)),
    nrow=2, ncol=1
)
```

### Summary

```{r cv all}
cv_all <- data.frame(cv.before, cv.eig)
colnames(cv_all) <- c("Before_KO", "Before_WT", "EigenMS_KO", "EigenMS_WT")

cv_ludovic_all <- data.frame(cv_ludovic.before, cv_ludovic.eig)
colnames(cv_ludovic_all) <- c("Before_KO", "Before_WT", "EigenMS_KO", "EigenMS_WT")
```

```{r cv summary}
#### NON-IMPUTED ####
cv_summary_KO <- cv_all |>   # calculating basic statistics for KO
    select(contains("KO")) |>
    pivot_longer(everything(), names_to = "method KO", values_to = "LFQ_CV") |>
    group_by(`method KO`) |>
    summarise("mean_KO"=round(mean(LFQ_CV, na.rm=TRUE),5), 
              "median_KO"=round(median(LFQ_CV, na.rm=TRUE),5), 
              "sd_KO"=round(sd(LFQ_CV, na.rm=TRUE),5))

cv_summary_WT <- cv_all |>   # calculating basic statistics for WT 
    select(contains("WT")) |>
    pivot_longer(everything(), names_to = "method WT", values_to = "LFQ_CV") |>
    group_by(`method WT`) |>
    summarise("mean_WT"=round(mean(LFQ_CV, na.rm=TRUE),5), 
              "median_WT"=round(median(LFQ_CV, na.rm=TRUE),5), 
              "sd_WT"=round(sd(LFQ_CV, na.rm=TRUE),5))

#### LUDOVIC ####
cv_ludovic_summary_KO <- cv_ludovic_all |>   # calculating basic statistics for KO
    select(contains("KO")) |>
    pivot_longer(everything(), names_to = "method KO", values_to = "LFQ_CV") |>
    group_by(`method KO`) |>
    summarise("mean_KO"=round(mean(LFQ_CV, na.rm=TRUE),5), 
              "median_KO"=round(median(LFQ_CV, na.rm=TRUE),5), 
              "sd_KO"=round(sd(LFQ_CV, na.rm=TRUE),5))

cv_ludovic_summary_WT <- cv_ludovic_all |>   # calculating basic statistics for WT
    select(contains("WT")) |>
    pivot_longer(everything(), names_to = "method WT", values_to = "LFQ_CV") |>
    group_by(`method WT`) |>
    summarise("mean_WT"=round(mean(LFQ_CV, na.rm=TRUE),5), 
              "median_WT"=round(median(LFQ_CV, na.rm=TRUE),5), 
              "sd_WT"=round(sd(LFQ_CV, na.rm=TRUE),5))

#### SUMMARY #### 
# prepare more readable output - Non-Ipmuted
cv_summary <- as.data.frame(cbind(cv_summary_KO, cv_summary_WT[-1]))
colnames(cv_summary)[1] <- "method"
cv_summary$method <- gsub("_KO", "", cv_summary$method)

# prepare more readable output - Ludovic
cv_ludovic_summary <- as.data.frame(cbind(cv_ludovic_summary_KO, cv_ludovic_summary_WT[-1]))
colnames(cv_ludovic_summary)[1] <- "method"
cv_ludovic_summary$method <- gsub("_KO", "", cv_ludovic_summary$method)
```

#### Non-Imputed 

```{r cv org summary}
show_cv_table(cv_summary)
```

#### Ludovic

```{r cv lud summary}
show_cv_table(cv_ludovic_summary)
```

## ICC {.tabset}

After normalization, biological replicates should group more tightly. We can 
assess this by measuring the **Intraclass Correlation Coefficient (ICC)** to see if 
replicates cluster together.

A guidelines for interpretation by [Koo and Li (2016)](https://doi.org/10.1016%2Fj.jcm.2016.02.012):

<div style="display: flex;">

<div style="flex: 50%;">
<ul>
<li>below 0.50: poor <span style="color:#D3D3D3;font-size:26px">■</span></li>
<li>between 0.50 and 0.75: moderate <span style="color:#aefda1;font-size:26px">■</span></li>
</ul>
</div>

<div style="flex: 50%;">
<ul>
<li>between 0.75 and 0.90: good <span style="color:#6dff54;font-size:26px">■</span></li>
<li>above 0.90: excellent <span style="color:#1bb400;font-size:26px">■</span></li>
</ul>
</div>

</div>

### Non-Imputed

```{r ICC1}
# Calculate ICC for Non-Imputed KO data
icc.KO.before <- irr::icc(2^LFQ_KO)$value
icc.KO.eig <- irr::icc(2^LFQ_KO.eigen)$value

# Bind all calculated ICCs to a data frame
icc.KO.all <- data.frame(`ICC KO`=c(icc.KO.before,icc.KO.eig))
rownames(icc.KO.all) <- c("Before", "EigenMS")

# Calculate ICC for Non-Imputed WT data
icc.WT.before <- irr::icc(2^LFQ_WT)$value
icc.WT.eig <- irr::icc(2^LFQ_WT.eigen)$value

# Bind all calculated ICCs to a data frame
icc.WT.all <- data.frame(`ICC WT`=c(icc.WT.before,icc.WT.eig))
rownames(icc.WT.all) <- c("Before","EigenMS")

# Show the table in a nice format
DT::datatable(cbind(icc.KO.all, icc.WT.all), 
              options=list(searching=FALSE, paging=FALSE, info=FALSE)) |>
    DT::formatStyle(columns = c("ICC.KO", "ICC.WT"), 
                    background = DT::styleInterval(c(0.5,0.75,0.9), c("#D3D3D3", "#aefda1", "#6dff54", "#1bb400")))
```

### Ludovic

```{r ICC2}
# Calculate ICC for Imputed KO data using ludovic
icc_ludovic.KO.before <- irr::icc(2^LFQ_KO_ludovic)$value
icc_ludovic.KO.eig <- irr::icc(2^LFQ_KO_ludovic.eigen)$value

# Bind all calculated ICCs to a data frame
icc_ludovic.KO.all <- data.frame(`ICC KO`=c(icc_ludovic.KO.before,icc_ludovic.KO.eig))
rownames(icc_ludovic.KO.all) <- c("Before","EigenMS")

# Calculate ICC for Imputed KO data using ludovic
icc_ludovic.WT.before <- irr::icc(2^LFQ_WT_ludovic)$value
icc_ludovic.WT.eig <- irr::icc(2^LFQ_WT_ludovic.eigen)$value

# Bind all calculated ICCs to a data frame
icc_ludovic.WT.all <- data.frame(`ICC WT`=c(icc_ludovic.WT.before,icc_ludovic.WT.eig))
rownames(icc_ludovic.WT.all) <- c("Before","EigenMS")

# Show the table in a nice format
DT::datatable(cbind(icc_ludovic.KO.all, icc_ludovic.WT.all), 
              options=list(searching=FALSE, paging=FALSE, info=FALSE)) |>
    DT::formatStyle(columns = c("ICC.KO", "ICC.WT"), 
                    background = DT::styleInterval(c(0.5,0.75,0.9), c("#D3D3D3", "#aefda1", "#6dff54", "#1bb400")))
```

## t-test 0.05 {.tabset}

In our project we used the paired t-test, which is a test based on the differences
between the values of a single pair, i.e., one deducted from the other. The 
formula for the paired t-test is given by:

$$t = \frac{\sum{d}}{\sqrt{\frac{n(\sum{d^2})-(\sum{d})^2}{n-1}}}$$

Where:

* $d$ is a difference per paired value;
* $n$ is number of samples.

In our calculations, we tested the following hypothesis:

$H_0$: There is no significant difference between the means of the two groups. <br>
$H_1$: There is a significant difference between the two population means.

```{r cutoffs}
p.cutoff = 0.05
FC.cutoff = 1 # set fold change cutoff 
```

### Raw Data

```{r p-value raw data}
# prepare data for t-test
df <- lfq[-which(miss_type$miss == "MNAR"),]

# calculate the p-values for our data
pvalue <- df |>
    dplyr::mutate("p_OCIAD1_MITOS" = apply(df, 1, ttest, 
                  grp1=grep("KO", colnames(df)), 
                  grp2=grep("WT", colnames(df)))) |>
    dplyr::mutate(significant = ifelse(p_OCIAD1_MITOS < p.cutoff, TRUE, FALSE),
                  protein.ids = protein.groups$`Protein IDs`[rows.to.keep][-which(miss_type$miss == "MNAR")]) # add a significance column 
m <- mean(pvalue$p_OCIAD1_MITOS, na.rm=TRUE) # mean of p
me <- median(pvalue$p_OCIAD1_MITOS, na.rm=TRUE) # median of p

# Plotting the histogram of the p-values filled with a significance info
hist_p <- ggplot(data = pvalue, aes(x = p_OCIAD1_MITOS, fill=significant)) + 
    geom_histogram(bins = 100) + ggtitle("Non-Imputed - p.value") +
    annotate("text", x = Inf, y = Inf, label = paste("μ(p) =", round(m, 3), "\nmed(p) =", round(me,3)), 
             hjust = 1.1, vjust = 1.3, size = 4, color = "black")
```

```{r p-value ludovic data}
# calculate the p-values for our data
pvalue_ludovic <- imputed_ludovic |>
    dplyr::mutate("p_OCIAD1_MITOS" = apply(imputed_ludovic, 1, ttest, 
                  grp1=grep("KO", colnames(imputed_ludovic)), 
                  grp2=grep("WT", colnames(imputed_ludovic)))) |>
    dplyr::mutate(significant = ifelse(p_OCIAD1_MITOS < p.cutoff, TRUE, FALSE),
                  protein.ids = protein.groups$`Protein IDs`[rows.to.keep]) # add a significance column 
m <- mean(pvalue_ludovic$p_OCIAD1_MITOS, na.rm=TRUE) # mean of p
me <- median(pvalue_ludovic$p_OCIAD1_MITOS, na.rm=TRUE) # median of p

# Plotting the histogram of the p-values filled with a significance info
hist_p_ludovic <- ggplot(data = pvalue_ludovic, aes(x = p_OCIAD1_MITOS, fill=significant)) + 
    geom_histogram(bins = 100) + ggtitle("Imputed ludovic - p.value") + theme(legend.position = "none") +
    annotate("text", x = Inf, y = Inf, label = paste("μ(p) =", round(m, 3), "\nmed(p) =", round(me,3)), 
             hjust = 2.1, vjust = 1.3, size = 3.5, color = "black")
```

```{r show raw p-value}
ggarrange(
    hist_p,
    hist_p_ludovic,
    nrow=2
)
```

### EigenMS

```{r p-value raw data eigen}
# prepare data for t-test
eigen_df1 <- cbind.data.frame(LFQ_KO.eigen, LFQ_WT.eigen)
eigen_df <- eigen_df1[-which(miss_type$miss == "MNAR"),]

# calculate the p-values for our data
pvalue_eigen <- eigen_df |>
    dplyr::mutate("p_OCIAD1_MITOS" = apply(eigen_df, 1, ttest, 
                  grp1=grep("KO", colnames(eigen_df)), 
                  grp2=grep("WT", colnames(eigen_df)))) |>
    dplyr::mutate(significant = ifelse(p_OCIAD1_MITOS < p.cutoff, TRUE, FALSE),
                  protein.ids = protein.groups$`Protein IDs`[rows.to.keep][-which(miss_type$miss == "MNAR")]) # add a significance column
m <- mean(pvalue_eigen$p_OCIAD1_MITOS, na.rm=TRUE) # mean of p
me <- median(pvalue_eigen$p_OCIAD1_MITOS, na.rm=TRUE) # median of p

# Plotting the histogram of the p-values filled with a significance info
hist_p_eigen <- ggplot(data = pvalue_eigen, aes(x = p_OCIAD1_MITOS, fill=significant)) + 
    geom_histogram(bins = 100) + ggtitle("Non-Imputed - p.value") +
    annotate("text", x = Inf, y = Inf, label = paste("μ(p) =", round(m, 3), "\nmed(p) =", round(me,3)), 
             hjust = 1.1, vjust = 1.3, size = 4, color = "black")
```

```{r p-value ludovic data eigen}
# prepare data for t-test
eigen_df_ludovic <- cbind.data.frame(LFQ_KO_ludovic.eigen, LFQ_WT_ludovic.eigen)

# calculate the p-values for our data
pvalue_eigen_ludovic <- eigen_df_ludovic |>
    dplyr::mutate("p_OCIAD1_MITOS" = apply(eigen_df_ludovic, 1, ttest, 
                  grp1=grep("KO", colnames(eigen_df_ludovic)), 
                  grp2=grep("WT", colnames(eigen_df_ludovic)))) |>
    dplyr::mutate(significant = ifelse(p_OCIAD1_MITOS < p.cutoff, TRUE, FALSE),
                  protein.ids = protein.groups$`Protein IDs`[rows.to.keep]) # add a significance column
m <- mean(pvalue_eigen_ludovic$p_OCIAD1_MITOS, na.rm=TRUE) # mean of p
me <- median(pvalue_eigen_ludovic$p_OCIAD1_MITOS, na.rm=TRUE) # median of p

# Plotting the histogram of the p-values filled with a significance info
hist_p_eigen_ludovic <- ggplot(data = pvalue_eigen_ludovic, aes(x = p_OCIAD1_MITOS, fill=significant)) + 
    geom_histogram(bins = 100) + ggtitle("Imputed ludovic - p.value") + theme(legend.position = "none") +
    annotate("text", x = Inf, y = Inf, label = paste("μ(p) =", round(m, 3), "\nmed(p) =", round(me,3)), 
             hjust = 2.1, vjust = 1.3, size = 4, color = "black")
```

```{r show eigen p-value}
ggarrange(
    hist_p_eigen,
    hist_p_eigen_ludovic,
    nrow=2
)
```

# Raw VS Normalized     

```{r prepare data}
# Create a data frame to make interactive plot
data <- data.frame(
    Gene_Name = rep(protein.groups$`Gene names`[rows.to.keep], each=6),
    lfq[,1:6] |> 
        tidyr::pivot_longer(cols=everything(), names_to = "Batch", values_to = "Raw"),
    eigen_df1 |> 
        tidyr::pivot_longer(cols=everything(), names_to = "Batch2", values_to = "Eigen.Raw"),
    imputed_ludovic[,3:8] |> 
        tidyr::pivot_longer(cols=everything(), names_to = "Batch5", values_to = "Ludovic"),
    as_tibble(LFQ_ludovic.eig_norm$norm_m) |> 
        tidyr::pivot_longer(cols=everything(), names_to = "Batch6", values_to = "Eigen.Ludovic")
)|>
    dplyr::select(Gene_Name, Batch, Raw, Eigen.Raw, Ludovic, Eigen.Ludovic)

data[, 3:6][is.na(data[, 3:6])] <- 0
```

<div style="display: flex;">

<div style="flex: 50%;">

```{r input1}
# Define user input from a list of genes
shiny::selectInput("gene", "Select Gene:", choices = unique(data$Gene_Name))
```

</div>

<div style="flex: 50%;">

```{r input2}
# Define the user input of the Y lims
shiny::sliderInput("bottom_y", "Select the bottom level of the Y axis:", 0, 40, 15)
shiny::sliderInput("upper_y", "Select the upper level of the Y axis:", 0, 40, 30)
```

</div>

</div>

```{r interactive bar-plot}
# Creating output with interactive bar plot
output$genePlot <- renderPlotly({
  selected_gene <- input$gene
  bottom_y <- input$bottom_y
  upper_y <- input$upper_y

  # Filter data for selected gene
  filtered_data <- data |>
      dplyr::filter(Gene_Name == selected_gene)
  
  # Create the plot
  plot_ly(data = filtered_data, type = "bar") |>
      add_trace(x = ~Batch, y = ~Raw, name = "Raw") |>
      add_trace(x = ~Batch, y = ~Eigen.Raw, name = "Eigen Raw") |>
      add_trace(x = ~Batch, y = ~Ludovic, name = "Ludovic") |>
      add_trace(x = ~Batch, y = ~Eigen.Ludovic, name = "Eigen Ludovic") |>
      layout(
      title = paste("Bar Plot for Gene:", selected_gene),
      xaxis = list(title = NULL),
      yaxis = list(title = "LFQ Values", range = c(bottom_y,upper_y))
      )
})
```

```{r show bar-plot}
plotlyOutput("genePlot")
```

# Fold Change

<div style="display: flex;">

<div style="flex: 33%;">

```{r input3}
shiny::selectInput("p.cutoff", "Select the p-value cut off:", c(0.05, 0.06))
```

</div>

<div style="flex: 33%;">

```{r input4}
shiny::selectInput("p.type", "Select the type of p-value:", c("p-value", "adj p-value"))
```

</div>

<div style="flex: 33%;">

```{r input5}
shiny::selectInput("adj.method", "Select the p-value adjustment method:", 
                   c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"))
```

</div>

</div>

## Raw Data {.tabset}

### Non-Imputed

```{r fc raw data}
# Preparing data for calculations
lfq5 <- cbind.data.frame(lfq[-which(miss_type$miss == "MNAR"),], 
                         protein.ids=protein.groups$`Protein IDs`[rows.to.keep][-which(miss_type$miss == "MNAR")],
                         gene = protein.groups$`Gene names`[rows.to.keep][-which(miss_type$miss == "MNAR")])
lfq_long <- lfq5 |>
    tidyr::pivot_longer(1:6, names_to = "sample", values_to = "LFQvalue")

# Add a new column with groups KO or WT
lfq_long$group <- "MITOS_OCIAD1_KO"
lfq_long$group[grep("WT",lfq_long$sample)] <- "MITOS_OCIAD1_WT"

# Calculation of means for groups KO and WT
means <- lfq_long |>
    dplyr::group_by(group, protein.ids) |>
    dplyr::summarise(mean=mean(LFQvalue, na.rm=TRUE)) |>
    dplyr::ungroup()

means <- tidyr::pivot_wider(means, names_from = group, values_from = mean) |>
    dplyr::mutate(FC_OCIAD1 = MITOS_OCIAD1_KO - MITOS_OCIAD1_WT)

means <- merge(means, miss_type[-which(miss_type$miss == "MNAR"),], by = "protein.ids")

# Preparing data for volcano plot
FC <- merge(means, lfq5, by = "protein.ids")

to_volcano1 <- merge(FC, pvalue, by = "protein.ids")
to_volcano1$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano1$FC_OCIAD1)>FC.cutoff&
                                           to_volcano1$p_OCIAD1_MITOS<p.cutoff,
                                       yes = TRUE, no = FALSE)
```

```{r v1}
# plotting the volcano plot
output$V1 <- renderPlotly({
    p.cutoff_sel <- as.numeric(input$p.cutoff)
    p.type <- input$p.type
    selected_gene <- input$gene
    adj_method <- input$adj.method
    
    selected_row <- which(to_volcano1$gene == selected_gene)
    if (length(selected_row) != 0) {
        sel_gene_data <- to_volcano1 |> dplyr::filter(gene == selected_gene)
        to_volcano <- to_volcano1[-selected_row,]
    } else {
        to_volcano <- to_volcano1
    }
    
    if (p.type == "adj p-value") {
        to_volcano$p_OCIAD1_MITOS <- p.adjust(to_volcano$p_OCIAD1_MITOS, adj_method)
        to_volcano$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_MITOS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    } else {
        to_volcano$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_MITOS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    }

    
    # Base plot
    v <- plotly::plot_ly(data = to_volcano, 
                         x = ~FC_OCIAD1, 
                         y = ~-log10(p_OCIAD1_MITOS), 
                         type = "scatter", 
                         mode = "markers", 
                         color = ~miss, 
                         text = ~gene,
                         symbol = ~sig_MITOS_OCIAD1,
                         hoverinfo = list("text", "symbol"), # Show label on hover
                         marker = list(size = 5)) |>  # Adjust marker size as needed
        layout(title = paste("Volcano plot for Non-Imputed Data -", p.type),
               xaxis = list(title = "log2(fold change)"),
               yaxis = list(title = paste("-log10(",p.type,")", sep="")),
               shapes = list(
                   list(type = "line", x0 = -1, x1 = -1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_MITOS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = 1, x1 = 1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_MITOS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = min(to_volcano$FC_OCIAD1), x1 = max(to_volcano$FC_OCIAD1), 
                        y0 = -log10(p.cutoff_sel), y1 = -log10(p.cutoff_sel),
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7)
               ))
    
    # Add selected genes if any are selected
    if (length(selected_row) != 0) {
        v <- v |> add_markers(data = sel_gene_data, 
                               x = ~FC_OCIAD1, 
                               y = ~-log10(p_OCIAD1_MITOS), 
                               marker = list(color = "brown", size = 10),
                               inherit = FALSE, # Make sure these points stand out
                               name = selected_gene)  
    }
    
    # Display the plot
    v
})

plotlyOutput("V1")
```

### Ludovic

```{r fc ludovic data}
# Preparing data for calculations
imputed_ludovic <- cbind.data.frame(imputed_ludovic, 
                                    protein.ids=protein.groups$`Protein IDs`[rows.to.keep],
                                    gene = protein.groups$`Gene names`[rows.to.keep])
imputed_long_ludovic <- imputed_ludovic |>
    tidyr::pivot_longer(3:8, names_to = "sample", values_to = "LFQvalue")

# Add a new column with groups KO or WT
imputed_long_ludovic$group <- "MITOS_OCIAD1_KO"
imputed_long_ludovic$group[grep("WT",imputed_long_ludovic$sample)] <- "MITOS_OCIAD1_WT"

# Calculation of means for groups KO and WT
means <- imputed_long_ludovic |>
    dplyr::group_by(group, protein.ids) |>
    dplyr::summarise(mean=mean(LFQvalue, na.rm=TRUE)) |>
    dplyr::ungroup()

means <- tidyr::pivot_wider(means, names_from = group, values_from = mean) |>
    dplyr::mutate(FC_OCIAD1 = MITOS_OCIAD1_KO - MITOS_OCIAD1_WT)

means <- merge(means, miss_type, by = "protein.ids")

# Preparing data for volcano plot
FC <- merge(means, imputed_ludovic, by = "protein.ids")

to_volcano5 <- merge(FC, pvalue_ludovic, by="Protein IDs")
to_volcano5$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano5$FC_OCIAD1)>FC.cutoff&
                                           to_volcano5$p_OCIAD1_MITOS<p.cutoff,
                                       yes = TRUE, no = FALSE)
```

```{r v5}
# Plotting the volcano plot
output$V5 <- renderPlotly({
    p.cutoff_sel <- as.numeric(input$p.cutoff)
    p.type <- input$p.type
    selected_gene <- input$gene
    adj_method <- input$adj.method
    
    selected_row <- which(to_volcano5$gene == selected_gene)
    if (length(selected_row) != 0) {
        sel_gene_data <- to_volcano5 |> dplyr::filter(gene == selected_gene)
        to_volcano <- to_volcano5[-selected_row,]
    } else {
        to_volcano <- to_volcano5
    }
    
    if (p.type == "adj p-value") {
        to_volcano$p_OCIAD1_MITOS <- p.adjust(to_volcano$p_OCIAD1_MITOS, adj_method)
        to_volcano$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_MITOS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    } else {
        to_volcano$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_MITOS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    }
    
    # Base plot
    v <- plotly::plot_ly(data = to_volcano, 
                         x = ~FC_OCIAD1, 
                         y = ~-log10(p_OCIAD1_MITOS), 
                         type = "scatter", 
                         mode = "markers", 
                         color = ~miss, 
                         text = ~gene,
                         symbol = ~sig_MITOS_OCIAD1,
                         hoverinfo = list("text", "symbol"),  # Show gene labels on hover
                         marker = list(size = 5)) |>  # Adjust marker size as needed
        layout(title = paste("Volcano plot for Imputed Data Ludovic -", p.type),
               xaxis = list(title = "log2(fold change)"),
               yaxis = list(title = paste("-log10(",p.type,")", sep="")),
               shapes = list(
                   list(type = "line", x0 = -1, x1 = -1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_MITOS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = 1, x1 = 1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_MITOS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = min(to_volcano$FC_OCIAD1), x1 = max(to_volcano$FC_OCIAD1), 
                        y0 = -log10(p.cutoff_sel), y1 = -log10(p.cutoff_sel),
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7)
               ))
    
    # Add selected genes if any are selected
    if (length(selected_row) != 0) {
        v <- v |> add_markers(data = sel_gene_data, 
                               x = ~FC_OCIAD1, 
                               y = ~-log10(p_OCIAD1_MITOS), 
                               marker = list(color = "brown", size = 10),
                               inherit = FALSE, # Make sure these points stand out
                               name = selected_gene) 
    }
    
    # Display the plot
    v
})
plotlyOutput("V5")
```

## EigenMS {.tabset}

### Non-Imputed

```{r fc eigen raw data}
# Preparing data for calculations
eigen_df <- cbind.data.frame(eigen_df1, protein.ids=protein.groups$`Protein IDs`[rows.to.keep],
                             gene = protein.groups$`Gene names`[rows.to.keep])
eigen_df_long <- eigen_df |>
    tidyr::pivot_longer(1:6, names_to = "sample", values_to = "LFQvalue")

# Add a new column with groups KO or WT
eigen_df_long$group <- "MITOS_OCIAD1_KO"
eigen_df_long$group[grep("WT",eigen_df_long$sample)] <- "MITOS_OCIAD1_WT"

# Calculation of means for groups KO and WT
means <- eigen_df_long |>
  dplyr::group_by(group, protein.ids) |>
  dplyr::summarise(mean=mean(LFQvalue, na.rm=TRUE)) |>
    dplyr::ungroup()

means <- tidyr::pivot_wider(means, names_from = group, values_from = mean) |>
    dplyr::mutate(FC_OCIAD1 = MITOS_OCIAD1_KO - MITOS_OCIAD1_WT)

means <- merge(means, miss_type, by = "protein.ids")

# Preparing data for volcano plot
FC <- merge(means, eigen_df, by = "protein.ids")

to_volcano7 <- merge(FC,pvalue_eigen, by = "protein.ids")
to_volcano7$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano7$FC_OCIAD1)>FC.cutoff&
                                           to_volcano7$p_OCIAD1_MITOS<p.cutoff,
                                       yes = TRUE, no = FALSE)
```

```{r v1 eigen}
# plotting the volcano plot
output$V1eig <- renderPlotly({
    p.cutoff_sel <- as.numeric(input$p.cutoff)
    p.type <- input$p.type
    selected_gene <- input$gene
    adj_method <- input$adj.method
    
    selected_row <- which(to_volcano7$gene == selected_gene)
    if (length(selected_row) != 0) {
        sel_gene_data <- to_volcano7 |> dplyr::filter(gene == selected_gene)
        to_volcano <- to_volcano7[-selected_row,]
    } else {
        to_volcano <- to_volcano7
    }
    
    if (p.type == "adj p-value") {
        to_volcano$p_OCIAD1_MITOS <- p.adjust(to_volcano$p_OCIAD1_MITOS, adj_method)
        to_volcano$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_MITOS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    } else {
        to_volcano$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_MITOS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    }
    
    # Base plot
    v <- plotly::plot_ly(data = to_volcano, 
                         x = ~FC_OCIAD1, 
                         y = ~-log10(p_OCIAD1_MITOS), 
                         type = "scatter", 
                         mode = "markers", 
                         color = ~miss, 
                         text = ~gene,
                         symbol = ~sig_MITOS_OCIAD1,
                         hoverinfo = list("text", "symbol"),  # Show labels on hover
                         marker = list(size = 5)) |>  # Adjust marker size as needed
        layout(title = paste("Volcano plot for Non-Imputed Data -", p.type),
               xaxis = list(title = "log2(fold change)"),
               yaxis = list(title = paste("-log10(",p.type,")", sep="")),
               shapes = list(
                   list(type = "line", x0 = -1, x1 = -1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_MITOS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = 1, x1 = 1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_MITOS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = min(to_volcano$FC_OCIAD1), x1 = max(to_volcano$FC_OCIAD1), 
                        y0 = -log10(p.cutoff_sel), y1 = -log10(p.cutoff_sel),
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7)
               ))
    
    # Add selected genes if any are selected
    if (length(selected_row) != 0) {
        v <- v |> add_markers(data = sel_gene_data, 
                               x = ~FC_OCIAD1, 
                               y = ~-log10(p_OCIAD1_MITOS), 
                               marker = list(color = "brown", size = 10),
                               inherit = FALSE, # Make sure these points stand out
                               name = selected_gene) 
    }
    
    # Display the plot
    v
})

plotlyOutput("V1eig")
```

### Ludovic

```{r fc eigen ludovic data}
# Preparing data for calculations
eigen_df_ludovic <- cbind.data.frame(eigen_df_ludovic, 
                                     protein.ids=protein.groups$`Protein IDs`[rows.to.keep],
                                     gene = protein.groups$`Gene names`[rows.to.keep])
eigen_df_long_ludovic <- eigen_df_ludovic |>
    tidyr::pivot_longer(1:6, names_to = "sample", values_to = "LFQvalue")

# Add a new column with groups KO or WT
eigen_df_long_ludovic$group <- "MITOS_OCIAD1_KO"
eigen_df_long_ludovic$group[grep("WT",eigen_df_long_ludovic$sample)] <- "MITOS_OCIAD1_WT"

# Calculation of means for groups KO and WT
means <- eigen_df_long_ludovic |>
  dplyr::group_by(group, protein.ids) |>
  dplyr::summarise(mean=mean(LFQvalue, na.rm=TRUE)) |>
    dplyr::ungroup()

means <- tidyr::pivot_wider(means, names_from = group, values_from = mean) |>
    dplyr::mutate(FC_OCIAD1 = MITOS_OCIAD1_KO - MITOS_OCIAD1_WT)

means <- merge(means, miss_type, by = "protein.ids")

# Preparing data for volcano plot
FC <- merge(means, eigen_df_ludovic, by = "protein.ids")

to_volcano11 <- merge(FC, pvalue_eigen_ludovic, by = "protein.ids")
to_volcano11$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano11$FC_OCIAD1)>FC.cutoff&
                                           to_volcano11$p_OCIAD1_MITOS<p.cutoff,
                                       yes = TRUE, no = FALSE)
```

```{r v5 eigen}
# Plotting the volcano plot
output$V5eig <- renderPlotly({
    p.cutoff_sel <- as.numeric(input$p.cutoff)
    p.type <- input$p.type
    selected_gene <- input$gene
    adj_method <- input$adj.method
    
    selected_row <- which(to_volcano11$gene == selected_gene)
    if (length(selected_row) != 0) {
        sel_gene_data <- to_volcano11 |> dplyr::filter(gene == selected_gene)
        to_volcano <- to_volcano11[-selected_row,]
    } else {
        to_volcano <- to_volcano11
    }
    
    if (p.type == "adj p-value") {
        to_volcano$p_OCIAD1_MITOS <- p.adjust(to_volcano$p_OCIAD1_MITOS, adj_method)
        to_volcano$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_MITOS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    } else {
        to_volcano$sig_MITOS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_MITOS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    }
    
    # Base plot
    v <- plotly::plot_ly(data = to_volcano, 
                         x = ~FC_OCIAD1, 
                         y = ~-log10(p_OCIAD1_MITOS), 
                         type = "scatter", 
                         mode = "markers", 
                         color = ~miss, 
                         text = ~gene,
                         symbol = ~sig_MITOS_OCIAD1,
                         hoverinfo = list("text", "symbol"),  # Show labels on hover
                         marker = list(size = 5)) |>  # Adjust marker size as needed
        layout(title = paste("Volcano plot for Imputed Data Ludovic -", p.type),
               xaxis = list(title = "log2(fold change)"),
               yaxis = list(title = paste("-log10(",p.type,")", sep="")),
               shapes = list(
                   list(type = "line", x0 = -1, x1 = -1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_MITOS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = 1, x1 = 1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_MITOS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = min(to_volcano$FC_OCIAD1), x1 = max(to_volcano$FC_OCIAD1), 
                        y0 = -log10(p.cutoff_sel), y1 = -log10(p.cutoff_sel),
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7)
               ))
    
    # Add selected genes if any are selected
    if (length(selected_row) != 0) {
        v <- v |> add_markers(data = sel_gene_data, 
                               x = ~FC_OCIAD1, 
                               y = ~-log10(p_OCIAD1_MITOS), 
                               marker = list(color = "brown", size = 10),
                               inherit = FALSE, # Make sure these points stand out
                               name = selected_gene) 
    }
    
    # Display the plot
    v
})

plotlyOutput("V5eig")
```

## Table

The table below, show how many proteins are significant and how many are not significant.

```{r}
DT::datatable(
    rbind(Raw = table(to_volcano1$sig_MITOS_OCIAD1),
          Raw.Eigen = table(to_volcano7$sig_MITOS_OCIAD1),
          Ludovic = table(to_volcano5$sig_MITOS_OCIAD1),
          Ludovic.Eigen = table(to_volcano11$sig_MITOS_OCIAD1)),
    options=list(searching=FALSE, paging=FALSE, info=FALSE))
```

```{r}
protein.groups_ludovic_raw <- protein.groups
nas <- rep(NA,nrow(protein.groups))
imputed_ludovic_correct <- data.frame(KO.22=nas, KO.23=nas, KO.24=nas, WT.22=nas, WT.23=nas, WT.24=nas)
imputed_ludovic_correct[as.numeric(gsub("prot_", "", imputed_ludovic$`Protein IDs`)),] <- imputed_ludovic[,3:8]
protein.groups_ludovic_raw$`LFQ intensity KO_MITOS_22` <- imputed_ludovic_correct$KO.22
protein.groups_ludovic_raw$`LFQ intensity KO_MITOS_23` <- imputed_ludovic_correct$KO.23
protein.groups_ludovic_raw$`LFQ intensity KO_MITOS_24` <- imputed_ludovic_correct$KO.24
protein.groups_ludovic_raw$`LFQ intensity WT_MITOS_22` <- imputed_ludovic_correct$WT.22
protein.groups_ludovic_raw$`LFQ intensity WT_MITOS_23` <- imputed_ludovic_correct$WT.23
protein.groups_ludovic_raw$`LFQ intensity WT_MITOS_24` <- imputed_ludovic_correct$WT.24

protein.groups_ludovic_eigenms <- protein.groups
eigen_ludovic <- LFQ_ludovic.eig_norm$norm_m
eigen_ludovic_clean <- data.frame(KO.22=nas, KO.23=nas, KO.24=nas, WT.22=nas, WT.23=nas, WT.24=nas)
eigen_ludovic_clean[as.numeric(gsub("prot_", "", imputed_ludovic$`Protein IDs`)),] <- eigen_ludovic

protein.groups_ludovic_eigenms$`LFQ intensity KO_MITOS_22` <- eigen_ludovic_clean$KO.22
protein.groups_ludovic_eigenms$`LFQ intensity KO_MITOS_23` <- eigen_ludovic_clean$KO.23
protein.groups_ludovic_eigenms$`LFQ intensity KO_MITOS_24` <- eigen_ludovic_clean$KO.24
protein.groups_ludovic_eigenms$`LFQ intensity WT_MITOS_22` <- eigen_ludovic_clean$WT.22
protein.groups_ludovic_eigenms$`LFQ intensity WT_MITOS_23` <- eigen_ludovic_clean$WT.23
protein.groups_ludovic_eigenms$`LFQ intensity WT_MITOS_24` <- eigen_ludovic_clean$WT.24
```

```{r}
write.table(protein.groups_ludovic_raw, file="proteingroups_ludovic_raw_MITOS.txt", sep="\t", row.names = FALSE)

write.table(protein.groups_ludovic_eigenms, file="proteingroups_ludovic_eigenms_MITOS.txt", sep="\t", row.name=FALSE)
```