---
title: "MS Proteomics Analysis"
author: "Vanessa Linke"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    number_sections: true
    toc_float: true
    code_folding: show
---

# DATA PREPARATION

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

library(tidyverse)
library(plotly) #for interactive visualizations
library(sjmisc) #for rotate_df
library(knitr) #for kable
library(stringr)
library(dplyr)
library("org.Hs.eg.db")
library(biomaRt)
library(clusterProfiler)
library(enrichplot)
library(patchwork)
library(ggrepel)
#library(pheatmap)

mitocarta <- read_csv("Human.MitoCarta3.0.csv") 
```

## INFO ABOUT DATASET

Manual input that is required to run the code appropriately for the respective dataset. 

 rep == "22|23|24" ~ "O1"
 rep == "30|32|33" ~ "TB"
 
 TODO: Make the code more universal by putting all manual input into one R code chunk (i. e. “{r dataset}”) so that only this part will have to be modified if a new “”proteingroups.txt” from a new experiment comes in

```{r dataset}

# How many replicates were used?
reps = 3 #INPUT

control = "WT"
condition = "KO"

```

## LOAD DATA

Load in the data as it is output from MaxQuant and perform simple data processing, including log2 transformation.

```{r loaddata}

proteingroups <- read_tsv("proteinGroups.txt")

#remove only identified by site, reverse, and potential contaminant ones
proteingroups <- proteingroups %>% filter(is.na(`Only identified by site`),
                         is.na(Reverse),
                         is.na(`Potential contaminant`))

#extract quantitative (LFQ intensity columns) and identifier data (Protein IDs)
LFQ <- proteingroups %>% select(`Protein IDs`, starts_with("LFQ Intensity "))

LFQ_raw <- proteingroups %>% select(`Gene names`, starts_with("LFQ Intensity "))

LFQ <- LFQ %>% rotate_df(cn = TRUE)

#replace 0 with NA for missing values
LFQ[(LFQ==0)] <- NA

```

```{r loaddata (non-imputed analysis)}

# proteingroups <- read_tsv("proteinGroups.txt")
# 
# #remove only identified by site, reverse, and potential contaminant ones
# proteingroups <- proteingroups %>% filter(is.na(`Only identified by site`),
#                          is.na(Reverse),
#                          is.na(`Potential contaminant`))
# 
# #extract quantitative (LFQ intensity columns) and identifier data (Protein IDs)
# LFQ <- proteingroups %>% select(`Protein IDs`, starts_with("LFQ Intensity "))
# 
# LFQ[(LFQ==0)] <- NA
# 
# LFQ <- LFQ[complete.cases(LFQ),]  #Filtering (only for non-imputation analysis)
# 
# LFQ_raw <- LFQ
# 
# LFQ <- LFQ %>% rotate_df(cn = TRUE)

```

```{r LFQ means}
LFQ_raw_mit <- LFQ_raw %>% select(contains("MITOS"))

LFQ_mean_mit <- data.frame(as.list(colMeans(LFQ_raw_mit)))

LFQ_mean_mit <- LFQ_mean_mit %>% pivot_longer(everything(), names_to = "Condition")

LFQ_raw_mit <- LFQ_raw_mit %>% log2() %>% pivot_longer(everything(), names_to = "Condition") 

labels <- c("LFQ_OCIAD1_KO1", "LFQ_OCIAD1_KO2", "LFQ_OCIAD1_KO3", "LFQ_TIMM17B_KO1", "LFQ_TIMM17B_KO2", "LFQ_TIMM17B_KO3", "LFQ_OCIAD1_WT1", "LFQ_OCIAD1_WT2", "LFQ_OCIAD1_WT3", "LFQ_TIMM17B_WT1", "LFQ_TIMM17B_WT2", "LFQ_TIMM17B_WT3")

```

```{r LFQ means plot}
bar1 <- ggplot(data = LFQ_raw_mit, aes(x = Condition, y = value)) +
  geom_violin() +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.text.y = element_text(angle = 60)) +
  scale_x_discrete(labels = labels) +
  labs(x = "", y = "LFQ")


ggplotly(bar1)
```

```{r processing}

#log2 transform the data for normal distribution
LFQ <- log2(LFQ)

#get experimental design info from file names (this is highly dependent on naming scheme!)
LFQ <- LFQ %>% rownames_to_column(var = "filename") %>%
  mutate(.before = 1, "Sample" = str_replace(filename, "LFQ intensity ", "")) %>%
  separate(col =  Sample, into = c("celltype","sampletype","rep"), sep = "_", remove = F) %>%
  mutate(.before = 1,
  "Exp" = case_when(
    rep == "22" ~ "Exp1",
    rep == "23" ~ "Exp1",
    rep == "24" ~ "Exp1",
    rep == "30" ~ "Exp2",
    rep == "32" ~ "Exp2",
    rep == "33" ~ "Exp2",
    TRUE ~ "other")) %>%
  mutate("Group" = paste0(sampletype, "_", Exp, "_", celltype), .before = 2)

unique(LFQ$Group) #What sample groups are in the data?

#remove columns that have only NA
not_all_na <- function(x) any(!is.na(x))
LFQ <- LFQ %>% select(where(not_all_na))
rownames(LFQ) <- LFQ$Sample

#long format is often more useful
LFQ_long <- LFQ %>%
  #select(!c(Group, Exp, Sample, filename, sampletype, celltype, rep)) %>%
pivot_longer(cols = where(is.numeric), names_to = "Protein IDs", values_to = "LFQvalue")
#LFQ_long$LFQvalue <- as.numeric(LFQ_long$LFQvalue)

# save the rest of the data as metadata
metadata <- proteingroups %>% select(`Protein IDs`, which(!colnames(proteingroups) %in% colnames(LFQ)))
rownames(metadata) <- metadata$`Protein IDs`
```

```{r imputation}

impute_data = function(df, width = 0.3, downshift = 1.8, seed = 7694) {
  # df = data frame containing filtered
  # Assumes missing data (in df) follows a narrowed and downshifted normal distribution

  set.seed(seed)

  # Create new column indicating whether the values are imputed
  df$imputed = !is.finite(df$LFQvalue)

  # Imputation
  temp <- df$LFQvalue
  temp[!is.finite(temp)] = NA #make sure all non-finite values are really NA
  temp.sd = width * sd(temp, na.rm = TRUE)   # shrink sd width
  temp.mean = mean(temp, na.rm = TRUE) -
    downshift * sd(temp, na.rm = TRUE)   # shift mean of imputed values
  n.missing = sum(is.na(temp))
  temp[is.na(temp)] = rnorm(n.missing, mean = temp.mean, sd = temp.sd)

  df$LFQvalue <- temp

  return(df)
}

LFQ_long$No <- c(1:dim(LFQ_long)[1])

## Apply imputation
LFQ.imp <- impute_data(data.frame(LFQ_long))

## Apply imputation by group (total vs mito)
LFQ_long_total <- LFQ_long[grep("MITO", LFQ_long$Group, invert=T),]
LFQ_long_mito <- LFQ_long[grep("MITO", LFQ_long$Group),]

LFQ.imp_total <- impute_data(data.frame(LFQ_long_total))
LFQ.imp_mito <-impute_data(data.frame(LFQ_long_mito))

LFQ.imp_bygroup <- rbind(LFQ.imp_mito, LFQ.imp_total)
LFQ.imp_bygroup <- LFQ.imp_bygroup[order(LFQ.imp_bygroup$No),]

# ggplotly(
#   ggplot(LFQ.imp, aes(x=LFQvalue, fill=imputed)) + 
#            geom_histogram(alpha=0.3, binwidth = 0.25, position = 'identity') +
#            facet_wrap(~ Group, ncol = 2)
#          )
# 
# ggplotly(
#   ggplot(LFQ.imp_bygroup, aes(x=LFQvalue, fill=imputed)) + 
#            geom_histogram(alpha=0.3, binwidth = 0.25, position = 'identity') +
#            facet_wrap(~ Group, ncol = 2)
#          )
# 
# ggplotly(
#   ggplot(LFQ.imp, aes(x=LFQvalue, fill=imputed)) + 
#            geom_histogram(alpha=0.3, binwidth = 0.25, position = 'identity') +
#            facet_wrap(~ Sample, ncol = 4)
#          )
# 
# ggplotly(
#   ggplot(LFQ.imp_bygroup, aes(x=LFQvalue, fill=imputed)) + 
#            geom_histogram(alpha=0.3, binwidth = 0.25, position = 'identity') +
#            facet_wrap(~ Sample, ncol = 4)
#          )
```

```{r imputation (non-imputation analysis)}

# impute_data = function(df, width = 0.3, downshift = 1.8, seed = 7694) {
#   # df = data frame containing filtered
#   # Assumes missing data (in df) follows a narrowed and downshifted normal distribution
# 
#   set.seed(seed)
# 
#   # Create new column indicating whether the values are imputed
#   df$imputed = !is.finite(df$LFQvalue)
# 
#   return(df)
# }
# 
# LFQ_long$No <- c(1:dim(LFQ_long)[1])
# 
# ## Apply imputation
# LFQ.imp <- impute_data(data.frame(LFQ_long))
# 
# ## Apply imputation by group (total vs mito)
# LFQ_long_total <- LFQ_long[grep("MITO", LFQ_long$Group, invert=T),]
# LFQ_long_mito <- LFQ_long[grep("MITO", LFQ_long$Group),]
# 
# LFQ.imp_total <- impute_data(data.frame(LFQ_long_total))
# LFQ.imp_mito <-impute_data(data.frame(LFQ_long_mito))
# 
# LFQ.imp_bygroup <- rbind(LFQ.imp_mito, LFQ.imp_total)
# LFQ.imp_bygroup <- LFQ.imp_bygroup[order(LFQ.imp_bygroup$No),]

```

```{r comparison of pre-imputed data}

totna <- is.na(LFQ_long_total$LFQvalue)
mitna <- is.na(LFQ_long_mito$LFQvalue)

ifelse(totna == mitna, print(1), print(0))

```

## FOLD-CHANGE CALCULATION

```{r FC}

LFQ.imp_wide <- LFQ.imp_bygroup %>%
  select(Sample, Protein.IDs, LFQvalue) %>% 
  pivot_wider(names_from = Sample, values_from = LFQvalue)
rownames(LFQ.imp_wide) <- LFQ.imp_wide$Protein.IDs

means <- LFQ.imp_bygroup %>%
  select(-Sample, -sampletype, -celltype, -rep, -filename, -No, -imputed) %>%
  group_by(Group, Protein.IDs) %>% 
  summarise(mean=mean(LFQvalue))

means <- pivot_wider(means, names_from = Group, values_from = mean) %>%
  mutate(FC_TOTALS_OCIAD1 = TOTALS_Exp1_KO - TOTALS_Exp1_WT,
         FC_MITOS_OCIAD1 = MITOS_Exp1_KO - MITOS_Exp1_WT,
         FC_TOTALS_TIMM17B = TOTALS_Exp2_KO - TOTALS_Exp2_WT,
         FC_MITOS_TIMM17B = MITOS_Exp2_KO - MITOS_Exp2_WT
           )

FC <- merge(means, LFQ.imp_wide)

metadata.mitocarta <- merge(metadata, mitocarta, by.x = "Gene names", by.y = "Symbol",  all.x = T)

FC <- merge(FC, metadata.mitocarta, by.x = 'Protein.IDs', by.y = 'Protein IDs')
```

## STATISTICS

to determine the significance of the fold-change FC calculated in the previous step

```{r stats}

ttest <- function(df, grp1, grp2){ 
  x = df[grp1]
  y = df[grp2]
  x = as.numeric((x))
  y = as.numeric((y))
  results = t.test(x,y, 
                   alternative = 'two.sided', #one-sided: 'greater' is x > y
                   paired = T,
                   na.action=na.omit) 
  results$p.value
}

p.cutoff = 0.05 #set p value cutoff
FC.cutoff = 1 # set fold change cutoff

pvalue <- LFQ.imp_wide %>% 
  mutate("p_OCIAD1_TOTALS" = apply(LFQ.imp_wide, 1, ttest, 
                  grp1=grep("KO_TOTALS_2", colnames(LFQ.imp_wide)), 
                  grp2=grep("WT_TOTALS_2", colnames(LFQ.imp_wide)))) %>%
  mutate("p_OCIAD1_MITOS" = apply(LFQ.imp_wide, 1, ttest, 
                  grp1=grep("KO_MITOS_2", colnames(LFQ.imp_wide)), 
                  grp2=grep("WT_MITOS_2", colnames(LFQ.imp_wide))))  %>%
  mutate("p_TIMM17B_TOTALS" = apply(LFQ.imp_wide, 1, ttest, 
                  grp1=grep("KO_TOTALS_3", colnames(LFQ.imp_wide)), 
                  grp2=grep("WT_TOTALS_3", colnames(LFQ.imp_wide)))) %>%
  mutate("p_TIMM17B_MITOS" = apply(LFQ.imp_wide, 1, ttest, 
                  grp1=grep("KO_MITOS_3", colnames(LFQ.imp_wide)), 
                  grp2=grep("WT_MITOS_3", colnames(LFQ.imp_wide))))

# ggplotly(
#   ggplot(pvalue, aes(x = p_OCIAD1_TOTALS)) +
#   geom_histogram(binwidth = 0.025, boundary = 0)
#   )
# 
# ggplotly(
#   ggplot(pvalue, aes(x = p_OCIAD1_MITOS)) +
#   geom_histogram(binwidth = 0.025, boundary = 0)
#   )
# 
# ggplotly(
#   ggplot(pvalue, aes(x = p_TIMM17B_TOTALS)) +
#   geom_histogram(binwidth = 0.025, boundary = 0)
#   )
# 
# ggplotly(
#   ggplot(pvalue, aes(x = p_TIMM17B_MITOS)) +
#   geom_histogram(binwidth = 0.025, boundary = 0)
#   )
# 
# table(pvalue$p_TIMM17B_TOTALS<0.05,pvalue$p_TIMM17B_MITOS<0.05)
```

## VOLCANO

```{r volcano}

volcano <- merge(FC, pvalue)# , by.y = "Row.names", by.x = 'Protein.IDs')
volcano$sig_MITOS_OCIAD1 <- ifelse(abs(volcano$FC_MITOS_OCIAD1)>FC.cutoff&
                        volcano$p_OCIAD1_MITOS<p.cutoff,
                      yes = TRUE, no = FALSE)

volcano$sig_TOTALS_OCIAD1 <- ifelse(abs(volcano$FC_TOTALS_OCIAD1)>FC.cutoff&
                        volcano$p_OCIAD1_TOTALS<p.cutoff,
                      yes = TRUE, no = FALSE)

volcano$sig_MITOS_TIMM17B <- ifelse(abs(volcano$FC_MITOS_TIMM17B)>FC.cutoff&
                        volcano$p_TIMM17B_MITOS<p.cutoff,
                      yes = TRUE, no = FALSE)

volcano$sig_TOTALS_TIMM17B <- ifelse(abs(volcano$FC_TOTALS_TIMM17B)>FC.cutoff&
                        volcano$p_TIMM17B_TOTALS<p.cutoff,
                      yes = TRUE, no = FALSE)


label.FC.cutoff <- 2.5
label.p.cutoff <- 0.05
  
# volcano$label_MITOS_TIMM17B <- ifelse(
#   abs(volcano$FC_MITOS_TIMM17B)>label.FC.cutoff & volcano$p_TIMM17B_MITOS<label.p.cutoff,
#                       yes = TRUE, no = #FALSE
#     ifelse(volcano$`Gene names` %in% c("TIMM17A", "TIMM17B", "TIMM23", "ROMO1", "TIMM21"), yes = TRUE, no = FALSE)
#     #ifelse(abs(volcano$FC_MITOS_TIMM17B)> 1 & !is.na(volcano$MitoCarta3.0_List) & volcano$rawpvalue<label.p.cutoff, yes = TRUE, no = FALSE)
# )
# 
# volcano$label_TOTALS_TIMM17B <- ifelse(
#   abs(volcano$FC_TOTALS_TIMM17B)>label.FC.cutoff & volcano$p_TIMM17B_TOTALS<label.p.cutoff,
#                       yes = TRUE, no = #FALSE
#     ifelse(volcano$`Gene names` %in% c("TIMM17A", "TIMM17B", "TIMM23", "ROMO1", "TIMM21"), yes = TRUE, no = FALSE)
#     #ifelse(abs(volcano$FC_MITOS_TIMM17B)> 1 & !is.na(volcano$MitoCarta3.0_List) & volcano$rawpvalue<label.p.cutoff, yes = TRUE, no = FALSE)
# )

cols_to_select <- c("sig_MITOS_OCIAD1", "FC_MITOS_OCIAD1", "p_OCIAD1_MITOS")
  #c("sig_TOTALS_OCIAD1", "FC_TOTALS_OCIAD1", "p_OCIAD1_TOTALS")
  #c("sig_MITOS_TIMM17B", "FC_MITOS_TIMM17B", "p_TIMM17B_MITOS")
sig_col <- cols_to_select[1]
fc_col <- cols_to_select[2]
p_col <- cols_to_select[3]

# ggplotly(
#   volcano %>%
#   ggplot(aes(x = .data[[fc_col]] , y = -log10(.data[[p_col]]), 
# #                             color = MitoCarta3.0_MitoPathways, #.data[[sig_col]], 
#                              label = Protein.IDs, 
#                              label2 = `Gene names`,
#              label3 = `Protein names`,
#              label4 = MitoCarta3.0_SubMitoLocalization,
#              label5 = MitoCarta3.0_MitoPathways
#                              ), show.legend = FALSE) + 
#            geom_point() + 
#            #scale_color_manual("Significant", values=as.character(c("grey","orange"))) +
#            theme_classic() +
#     geom_hline(yintercept=-log10(p.cutoff), size = 0.2, linetype="dashed", color = "lightgrey") +
#     geom_vline(xintercept=FC.cutoff, size = 0.2, linetype="dashed", color = "lightgrey") +
#     geom_vline(xintercept=-FC.cutoff, size = 0.2, linetype="dashed", color = "lightgrey") 
#          )
```

```{r filtering, summary}

output <- volcano %>% select(contains(c("Gene names", "Protein names", "SubMito", "MitoPath", "FC", "p_", "sig_", "Protein.IDs"), ignore.case = FALSE)) %>% 
  rowwise() %>%
  mutate("no_sig" = sum(c(sig_MITOS_OCIAD1, sig_TOTALS_OCIAD1, sig_MITOS_TIMM17B, sig_TOTALS_TIMM17B)),
         "combined_FC" = sum(c(abs(FC_TOTALS_OCIAD1), abs(FC_MITOS_OCIAD1), abs(FC_TOTALS_TIMM17B), abs(FC_MITOS_TIMM17B)))) %>%
  arrange(desc(no_sig), desc(combined_FC))

#output %>% filter(no_sig > 1) %>% select(`Gene names`) %>% unlist() %>% cat(sep = ", ")

reference <- output %>% select(`Gene names`)
```

```{r add chromosomal data}
# downloading all annotation
mart = useMart("ENSEMBL_MART_ENSEMBL", dataset = "hsapiens_gene_ensembl")
uniprots <- Rkeys(org.Hs.egUNIPROT)
ENSEMBL_ids <- AnnotationDbi::select(org.Hs.eg.db, uniprots, "ENSEMBL", "UNIPROT")

#########
# https://www.bioconductor.org/help/course-materials/2014/useR2014/Integration.html
# get chr info
#listFilters(mart)  
myFilter <- c("chromosome_name")
#listFilterOptions(mart, "chromosome_name")
myValues <- listFilterOptions(mart, "chromosome_name")[c(1:22,503:505)]
myAttributes <- c("ensembl_gene_id", "external_gene_name", listAttributes(mart)[9:13,1])
## assemble and query the mart
res <- getBM(attributes =  myAttributes, filters =  myFilter,
             values =  myValues, 
             mart = mart)
##########

my.data <- output %>% 
  mutate("UNIPROT" = gsub(";.*", "", Protein.IDs)) %>%
  mutate("UNIPROT" = gsub("-.*", "", UNIPROT))
my.data <- my.data %>% left_join(ENSEMBL_ids, by= "UNIPROT")
# 21 still un-annotated
my.data %>% filter(is.na(ENSEMBL)) %>% distinct(Protein.IDs) %>% dim()

my.data <- my.data %>% left_join(res, by=c("ENSEMBL" = "ensembl_gene_id"))
my.data <- my.data %>% distinct(`Gene names`, .keep_all = TRUE)
```

```{r volcano plot}
#show ociad1

my.data_temp <- my.data

my.data_temp$description <- case_when(
  grepl("Fatty acid oxidation", my.data$MitoCarta3.0_MitoPathways) ~ 2,
  grepl("Protein import", my.data$MitoCarta3.0_MitoPathways) ~ 3,
  !is.na(my.data$MitoCarta3.0_MitoPathways) ~ 1,
  TRUE ~ 0
)

my.data_temp$description <- factor(my.data_temp$description)


my.data_temp$label <- case_when(
  abs(my.data_temp$FC_MITOS_OCIAD1) > 2.5 & my.data_temp$sig_MITOS_OCIAD1 == TRUE & my.data_temp$description == 1 ~ my.data_temp$`Gene names`,
  my.data_temp$sig_MITOS_OCIAD1 == TRUE & my.data_temp$description == 2 ~ my.data_temp$`Gene names`,
  my.data_temp$sig_MITOS_OCIAD1 == TRUE & my.data_temp$description == 3 ~ my.data_temp$`Gene names`,
  my.data_temp$`Gene names` == 'OCIAD1' ~ my.data_temp$`Gene names`,
  my.data_temp$`Gene names` == 'TIMM17A' ~ my.data_temp$`Gene names`,
  my.data_temp$`Gene names` == 'TIMM17B' ~ my.data_temp$`Gene names`,
  my.data_temp$`Gene names` == 'TIMM23' ~ my.data_temp$`Gene names`,
  TRUE ~ ''
)

my.data_temp$color <- case_when(
  grepl("Fatty acid oxidation", my.data$MitoCarta3.0_MitoPathways) ~ 'blue',
  grepl("Protein import", my.data$MitoCarta3.0_MitoPathways) ~ 'darkorange',
  !is.na(my.data$MitoCarta3.0_MitoPathways) ~ '#76EE35',
  TRUE ~ 'darkgrey'
)


v1 <- ggplot(my.data_temp, aes(x = FC_MITOS_OCIAD1, y = -log10(p_OCIAD1_MITOS), shape = sig_MITOS_OCIAD1, color = description)) +
  geom_hline(yintercept = -log10(0.05), color = 'lightgrey', alpha = 0.6, linetype = 2) +
  geom_vline(xintercept = 1, color = 'lightgrey', alpha = 0.6, linetype = 2) +
  geom_vline(xintercept = -1, color = 'lightgrey', alpha = 0.6, linetype = 2) +
  geom_point(data = filter(my.data_temp, description == 0), stroke = 1.2, alpha = 0.4) +
  geom_point(data = filter(my.data_temp, description == 1), stroke = 1.2, alpha = 0.55) +
  geom_point(data = filter(my.data_temp, description == 2), stroke = 1.2, alpha = 0.7) +
  geom_point(data = filter(my.data_temp, description == 3), stroke = 1.2, alpha = 0.7) +
  xlab("Fold Change between KO and WT") +
  ylab("-log10(p-value)") +
  theme_bw() +
  theme(legend.position = c(0.01, 0.99), legend.justification = c("left", "top"), legend.title=element_blank(), legend.text = element_text(size=9), legend.background = element_blank(), legend.key = element_blank(),
  #theme(legend.justification = c("right", "bottom"), legend.title=element_blank(), legend.text = element_text(size=10), legend.background = element_blank(), legend.key = element_blank(),  
  panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  guides(shape=FALSE, alpha = FALSE) +
  scale_shape_manual(values = c(1, 16)) +
  xlim(-max(abs(my.data_temp$FC_MITOS_OCIAD1)), max(abs(my.data_temp$FC_MITOS_OCIAD1))) +
  scale_color_manual(labels = c('Non-mitochondrial', 'Other mitochondrial', 'Fatty acid oxidation', 'Protein import'), values = c('darkgrey', '#76EE35', 'blue', 'darkorange')) +
  geom_text_repel(aes(label = label), max.overlaps = Inf, verbose = TRUE, min.segment.length = 0, color = my.data_temp$color, box.padding = 1)

v1

```


## GO TERM ENRICHMENT

```{r GOprep}
Entrez_ids <- AnnotationDbi::select(org.Hs.eg.db, uniprots, "ENTREZID", "UNIPROT")

my.data <- output %>% 
  mutate("UNIPROT" = gsub(";.*", "", Protein.IDs)) %>%
  mutate("UNIPROT" = gsub("-.*", "", UNIPROT))
my.data <- my.data %>% left_join(Entrez_ids, by= "UNIPROT")
# 21 still un-annotated
my.data %>% filter(is.na(ENTREZID)) %>% distinct(Protein.IDs) %>% dim()

```

```{r GO}
# GO enrichment up
this.group.up <- my.data %>% filter(.data[[sig_col]] & .data[[fc_col]] > (1)) %>% select(ENTREZID) %>% pull() #no_sig > 1

this.ont = "ALL"

go_enrich.up <- enrichGO(gene = this.group.up, OrgDb="org.Hs.eg.db", 
                       universe = unique(sort(na.omit(my.data$ENTREZID))),
                       pvalueCutoff = 0.05, pAdjustMethod="fdr",
                       ont=this.ont)
go_enrichx.up <- setReadable(go_enrich.up, 'org.Hs.eg.db', 'ENTREZID')
go_enrichx2.up <- pairwise_termsim(go_enrichx.up)


# GO enrichment down
this.group.down <- my.data %>% filter(.data[[sig_col]] & .data[[fc_col]] < (-1)) %>% select(ENTREZID) %>% pull() #no_sig > 1

this.ont = "ALL"

go_enrich.down <- enrichGO(gene = this.group.down, OrgDb="org.Hs.eg.db", 
                       universe = unique(sort(na.omit(my.data$ENTREZID))),
                       pvalueCutoff = 0.05, pAdjustMethod="fdr",
                       ont=this.ont)
go_enrichx.down <- setReadable(go_enrich.down, 'org.Hs.eg.db', 'ENTREZID')
go_enrichx2.down <- pairwise_termsim(go_enrichx.down)

go_enrich_df.down <- as.data.frame(go_enrichx2.down)
```

``` {r GO plot terms up}
p_go_up <- barplot(go_enrichx2.up, showCategory=15, simplify = TRUE) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 9), axis.text.x = element_text(size = 11)) +
  scale_fill_gradient(low="blue",high="red")

p_go_up
```

```{r GO plot terms down}
p_go_down <- barplot(go_enrichx2.down, showCategory=15, simplify = TRUE) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 9), axis.text.x = element_text(size = 11)) +
  scale_fill_gradient(low="blue",high="red")
  
p_go_down
```

```{r GO plot heatmap up}
geneList <- setNames(my.data$FC_MITOS_OCIAD1, my.data$`Gene names`)
#go_enrich_filt.up <- subset(go_enrichx2.up, subset = geneID %in% as.character(my.data$`Gene names`))
color_scale <- scale_fill_gradient2(low = "red", mid = "grey", high = "green", midpoint = 0, limits = c(-5, 5))

p_go_heat_up <- heatplot(go_enrichx2.up, foldChange = geneList, showCategory=5) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 8), axis.text.x = element_text(size = 8, angle = 45, hjust = 0, vjust = 0), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  scale_fill_gradient(low="grey",high="green") +
  scale_y_discrete(position = 'right', labels = function(x) str_wrap(x, width = 25)) +
  coord_flip()

p_go_heat_up
```

```{r GO plot heatmap down}
geneList <- setNames(my.data$FC_MITOS_OCIAD1, my.data$`Gene names`)
color_scale <- scale_fill_gradient2(low = "red", mid = "grey", high = "green", midpoint = 0, limits = c(-5, 5))

p_go_heat_down <- heatplot(go_enrichx2.down, foldChange = geneList, showCategory=5) +
  theme_bw() +
  theme(axis.text.y = element_text(size = 8), axis.text.x = element_text(size = 8, angle = 45, hjust = 0, vjust = 0), panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  scale_fill_gradient(low="red",high="grey") +
  scale_y_discrete(position = 'right', labels = function(x) str_wrap(x, width = 25)) +
  coord_flip()

p_go_heat_down
```

```{r}
# direxn <- "up"
# #Which ones are changing but not included in a significantly enriched GO term
# if(direxn == "up") {
# v1 <- my.data %>% filter(.data[[sig_col]] & .data[[fc_col]] > (1)) %>% select(`Gene names`) %>% pull
# } else if(direxn == "down") {
#   v1 <- my.data %>% filter(.data[[sig_col]] & .data[[fc_col]] < (-1)) %>% select(`Gene names`) %>% pull
# }
# 
# v2 <- go_enrichx.up@result$geneID
# v2 <- v2 %>% paste(collapse = "/") %>% strsplit("/") 
# 
# ingo <- intersect(v1, v2[[1]])
# length(ingo) 
# # TIMM17B Totals up: 26 and all FC < 2
# # TIMM17B Totals down: 32
# notingo <- setdiff(v1, v2[[1]])
# length(notingo) 
# # TIMM17B Totals up: 57
# # TIMM17B Totals down: 53
# 
# #my.data %>% filter(`Gene names` %in% ingo) %>% View()
# #my.data %>% filter(`Gene names` %in% notingo) %>% View()
```

```{r one_GO_term}

this.ont = "CC" 

this.GO.perox = "GO:0005777" #peroxisome (cellular component)
this.GO.er = "GO:0005783" #ER
this.GO.ga = "GO:0005794" #golgi apparatus
this.GO.mito = "GO:0005739" #mitochondrium
this.GO.ribo = "GO:0005840" #ribosome
this.GO.lys = "GO:0005764" #lysosome
this.GO.endo = "GO:0005768" #endosome



GO_terms <- c(this.GO.perox, this.GO.lys, this.GO.endo, this.GO.er, this.GO.ga, this.GO.mito, this.GO.ribo)
organelles <- c('Peroxisome','Lysosome', 'Endosome', 'Endoplasmatic\nReticulum', 'Golgi\nApparatus', 'Mitochondrium', 'Ribosome')

FC_organ <- data.frame(`Gene names` = my.data$`Gene names`, `FC_MITOS_OCIAD1` = my.data$`FC_MITOS_OCIAD1`, `FC_TOTALS_OCIAD1` = my.data$`FC_TOTALS_OCIAD1`, Organelle = '')

for (n in 1:length(GO_terms)) {
  
  this.GO <- GO_terms[n]
  organ <- organelles[n]

  retrieved <- AnnotationDbi::select(org.Hs.eg.db, keytype = "GOALL", keys = this.GO, columns = c("ENSEMBL", "UNIPROT"))
  
  my.data_organ <- output %>% 
    mutate("UNIPROT" = gsub(";.*", "", Protein.IDs)) %>%
    mutate("UNIPROT" = gsub("-.*", "", UNIPROT))
  my.data_organ <- my.data_organ %>% left_join(retrieved, by= "UNIPROT")
  
  my.data_organ %>% filter(is.na(ENSEMBL)) %>% distinct(Protein.IDs) %>% dim()
  
  #my.data_organ <- my.data_organ %>% left_join(res, by=c("ENSEMBL" = "ensembl_gene_id"))
  
  my.list <- my.data_organ %>% filter(!is.na(GOALL)) %>% select(`Gene names`) %>% unique()
                                      
    #my.list <- my.data_organ %>% filter(!is.na(GOALL) && .data[[sig_col]]) %>% select(`Gene names`) %>% unique()

  
  FC_organ$Organelle <- ifelse(my.data$`Gene names` %in% my.list$`Gene names`, paste(organ, FC_organ$Organelle, sep = ";", collapse = NULL), FC_organ$Organelle)
  
}

FC_organ_long <- FC_organ %>% separate_rows(Organelle, sep = ";") 
  
FC_organ_long$Organelle[FC_organ_long$Organelle == ''] <- 'Unspecified'

FC_organ_long <- FC_organ_long %>% pivot_longer(c(FC_MITOS_OCIAD1, FC_TOTALS_OCIAD1), names_to = "Batch", values_to = "FC")
```


```{r}
# #, col = '#4B4B4B'
# #violin plot?
# organelle_boxplot <- ggplot(FC_organ_long, aes(x = reorder(`Organelle`, FC, FUN = mean), y = FC, fill = Batch)) + 
#   geom_hline(yintercept = 0, linetype = 'dashed', color = 'grey') +
# #  stat_boxplot(geom ='errorbar') + 
#   geom_violin(position = 'dodge', alpha = 0.5, outlier.shape = NA) +
#   #geom_boxplot(aes(middle = mean(FC_MITOS_OCIAD1)), alpha = 0, col = '#4B4B4B', outlier.shape = NA) +
# #  geom_jitter(width = 0.2, size = 1.2, shape = 16, col = '#4B4B4B') +
#   #ggtitle('OCIAD1 KO vs WT') +
#   ylab('Fold Change between KO and WT') +
#   theme_bw() +
#   theme(legend.position="none", axis.text.x = element_text(size = 11, angle = -55, hjust = 0), axis.title.x = element_blank()) +
#   guides(alpha = "none") +
#   scale_color_manual(c('red', 'blue'))
# 
#   #ylim(-max(abs(py$df_ociad1_mitos$FC)), max(abs(py$df_ociad1_mitos$FC))) +
#   # scale_alpha_manual(values = c(0.2, 0.8)) +
#   # scale_color_manual(values = py$palette) +
# 
# organelle_boxplot
```


```{r organelle grouped violin}

organelle_plot <- ggplot(FC_organ_long, aes(x = reorder(`Organelle`, FC, FUN = mean), y = FC, fill = Batch)) + 
  geom_hline(yintercept = 0, linetype = 'dashed', color = 'grey') +
  geom_violin(position = 'dodge', trim = FALSE, alpha = 0.6, col = '#4B4B4B', draw_quantiles = c(0.5), linewidth = 0.7
              , scale = "width", 
              ) +
  ylab('Fold Change between KO and WT') +
  theme_bw() +
  theme(axis.text.x = element_text(size = 11, angle = -55, hjust = 0), axis.title.x = element_blank(), legend.position = c(0.97, 0.01), legend.justification = c("right", "bottom"), legend.title=element_blank(), legend.text = element_text(size=9), legend.background = element_blank(), legend.key = element_blank()) +
  scale_fill_manual(labels = c('MITOS', 'TOTALS'), values = c('lightblue', 'red'))

organelle_plot
```

```{r violin split function}
GeomSplitViolin <- ggproto("GeomSplitViolin", GeomViolin,
  draw_group = function(self, data, ..., draw_quantiles = NULL) {
    # Original function by Jan Gleixner (@jan-glx)
    # Adjustments by Wouter van der Bijl (@Axeman)
    data <- transform(data, xminv = x - violinwidth * (x - xmin), xmaxv = x + violinwidth * (xmax - x))
    grp <- data[1, "group"]
    newdata <- plyr::arrange(transform(data, x = if (grp %% 2 == 1) xminv else xmaxv), if (grp %% 2 == 1) y else -y)
    newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
    newdata[c(1, nrow(newdata) - 1, nrow(newdata)), "x"] <- round(newdata[1, "x"])
    if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
      stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 1))
      quantiles <- create_quantile_segment_frame(data, draw_quantiles, split = TRUE, grp = grp)
      aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
      aesthetics$alpha <- rep(1, nrow(quantiles))
      both <- cbind(quantiles, aesthetics)
      quantile_grob <- GeomPath$draw_panel(both, ...)
      ggplot2:::ggname("geom_split_violin", grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
    }
    else {
      ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
    }
  }
)

create_quantile_segment_frame <- function(data, draw_quantiles, split = FALSE, grp = NULL) {
  dens <- cumsum(data$density) / sum(data$density)
  ecdf <- stats::approxfun(dens, data$y)
  ys <- ecdf(draw_quantiles)
  violin.xminvs <- (stats::approxfun(data$y, data$xminv))(ys)
  violin.xmaxvs <- (stats::approxfun(data$y, data$xmaxv))(ys)
  violin.xs <- (stats::approxfun(data$y, data$x))(ys)
  if (grp %% 2 == 0) {
    data.frame(
      x = ggplot2:::interleave(violin.xs, violin.xmaxvs),
      y = rep(ys, each = 2), group = rep(ys, each = 2)
    )
  } else {
    data.frame(
      x = ggplot2:::interleave(violin.xminvs, violin.xs),
      y = rep(ys, each = 2), group = rep(ys, each = 2)
    )
  }
}

geom_split_violin <- function(mapping = NULL, data = NULL, stat = "ydensity", position = "identity", ..., 
                              draw_quantiles = NULL, trim = TRUE, scale = "area", na.rm = FALSE, 
                              show.legend = NA, inherit.aes = TRUE) {
  layer(data = data, mapping = mapping, stat = stat, geom = GeomSplitViolin, position = position, 
        show.legend = show.legend, inherit.aes = inherit.aes, 
        params = list(trim = trim, scale = scale, draw_quantiles = draw_quantiles, na.rm = na.rm, ...))
}
```

```{r organelle split violin}

#print(table(FC_organ_long$Organelle))

organelle_plot <- ggplot(FC_organ_long, aes(x = reorder(`Organelle`, FC, FUN = function(x) -median(x)), y = FC, fill = Batch)) + 
  geom_hline(yintercept = 0, linetype = 'dashed', color = 'grey') +
  geom_split_violin(trim = FALSE ,alpha = 0.6, col = '#4B4B4B', draw_quantiles = c(0.5), linewidth = 0.7, scale = 'width') +
  ylab('Fold Change between KO and WT') +
  theme_bw() +
  theme(axis.text.x = element_text(size = 10), axis.title.y = element_blank(), legend.position = c(0.99, 1), legend.justification = c("right", "top"), legend.title=element_blank(), legend.text = element_text(size=9), legend.background = element_blank(), legend.key = element_blank()) +
  scale_fill_manual(labels = c('MITOS', 'TOTALS'), values = c('lightblue', 'red')) +
  #scale_x_discrete(labels = c('Peroxisome\n(174)*x', 'Endoplasmatic\nReticulum\n(1522)**', 'Golgi\nApparatus\n(1018)**', 'Ribosome\n(398)*x', 'Mitochondrium\n(2074)**', 'Unspecified\n(10618)x*')) +
  ylim(-6, 6) +
  coord_flip()

organelle_plot
```

```{r organelle significant, echo = FALSE}
organelles <- c('Peroxisome', 'Endoplasmatic\nReticulum', 'Golgi\nApparatus', 'Mitochondrium', 'Ribosome', 'Unspecified')
batches <- c('FC_MITOS_OCIAD1', 'FC_TOTALS_OCIAD1')
set <- c()

tppval <- c()
tsig <- c()
wppval <- c()
wsig <- c()
for (b in batches){
  for (org in organelles){
    set <- append(set, paste(org, b, sep=", "))
    fc_pc <- FC_organ_long[FC_organ_long$`Organelle` == org & FC_organ_long$`Batch` == b, ][['FC']]
    tt <- t.test(fc_pc, mu = 0)
    ww <- wilcox.test(fc_pc, mu = 0)
    tpp <- tt$p.value
    wpp <- ww$p.value
    wppval <- append(wppval, wpp)
    tppval <- append(tppval, tpp)
    tsigg <- ifelse(tpp < 0.05, 1, 0)
    tsig <- append(tsig, tsigg)
    wsigg <- ifelse(wpp < 0.05, 1, 0)
    wsig <- append(wsig, wsigg)
  }
}
something <- data.frame(`set` = set, `tpval` = tppval, `tsignificant` = tsig, `wpval` = wppval, `wsignificant` = wsig)

```

``` {r gather plots 1, echo = FALSE}
#go terms and organelles separate figures

v1 / (free(p_go_heat_down) | free(p_go_heat_up)) +
  #plot_layout(heights = c(1, 0.7, 0.7)) + #horizontal plots
  plot_layout(heights = c(0.7, 1)) + #vertical plots
  plot_annotation(tag_levels = "A")
  #plot_layout(guides = 'collect')
```

``` {r gather plots 2, echo = FALSE}
#go terms and organelles separate figures

organelle_plot +
  plot_layout(heights = c(1)) +
  plot_annotation(tag_levels = "A") 
```

