---
title: "TOTALS data analysis"
author: "Kacper Kaszuba"
date: "`r Sys.Date()`"
runtime: shiny
output: 
    html_document:
        toc: true
        toc_float: 
            collapsed: false
        code_download: true
fontsize: 14pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, fig.align = "center", fig.keep = "all", echo = FALSE)

library(ggplot2)
library(ggpubr)
library(dplyr)
library(tidyr)
library(protti)
library(plotly)
source("EigenMS/EigenMS/EigenMS.R")
source("fxn.R")
```

# Load Data

```{r load data}
# load raw data
protein.groups <- readr::read_tsv("./data/proteinGroups.txt", show_col_types = FALSE)

protein.groups <- protein.groups |> filter(is.na(`Only identified by site`),
                         is.na(Reverse),
                         is.na(`Potential contaminant`))

lfq <- protein.groups |>
    dplyr::select(dplyr::starts_with("LFQ Intensity") & (ends_with("22") | ends_with("23") | ends_with("24")) & dplyr::contains("TOTALS"))

colnames(lfq) <- gsub("_TOTALS_", ".", gsub("LFQ intensity ", "", colnames(lfq)))
lfq[lfq == 0] <- NA
lfq <- log2(lfq)
```

# Assign Missingness

```{r assign missingness}
# extracting columns to machine learning models
df_miss <- protein.groups |>
    select(starts_with("LFQ Intensity") 
           & (ends_with("22") | ends_with("23") | ends_with("24")) 
           & contains("TOTALS"))

# changing the colnames
colnames(df_miss) <- gsub("LFQ intensity ", "", colnames(df_miss))

# making longer data frame with one column containing all LFQ values
df_miss <- df_miss |>
    mutate(prot.id = paste("prot",1:nrow(df_miss),sep="_")) |>
    pivot_longer(1:6, names_to = "Sample", values_to = "LFQvalue") |>
    separate(col=Sample, into=c("celltype","sampletype","rep"), sep = "_", remove = FALSE) |>
    mutate(celltype = as.factor(celltype), sampletype = as.factor(sampletype),
                  rep = as.factor(rep))

# changing values with 0 to NA
df_miss$LFQvalue[df_miss$LFQvalue==0] <- NA

missingness <- assign_missing(df_miss$prot.id, df_miss$celltype, df_miss$LFQvalue)
df_miss$missingness_per_cond <- missingness$missingness_per_cond
df_miss$missingness_per_prot <- missingness$missingness_per_prot
df_miss$missingness <- missingness$missingness

df_miss$missingness[is.na(df_miss$missingness)] <- "all_NA"

# Remove unnecessary columns and reordering columns
df_miss <- df_miss |>
    select(-prot.id, -Sample) |>
    mutate(missingness_per_prot = as.factor(missingness_per_prot),
                  missingness_per_cond = as.factor(missingness_per_cond),
                  missingness = as.factor(missingness))
```

# Imputation

```{r protti}
df_to_protti <- protein.groups |>
    dplyr::select(`Protein IDs`, `Peptide sequences`, 
           contains("LFQ intensity") & contains("TOTALS") & (ends_with("22") | ends_with("23") | ends_with("24"))) |>
    dplyr::mutate(`Protein IDs`= paste("prot_", 1:nrow(protein.groups), sep="")) |>
    tidyr::pivot_longer(3:8, names_to = "Sample", values_to = "Intensity")|>
    dplyr::mutate(Sample = gsub("LFQ intensity ", "", Sample)) |>
    dplyr::mutate(Sample = gsub("_TOTALS_", "_", Sample)) |>
    tidyr::separate(col =  Sample, into = c("celltype","rep"), sep = "_", remove = F) |>
    dplyr::mutate(Condition = ifelse(celltype == "KO", "treated", "control"),
           Intensity = ifelse(Intensity == 0, NA, log2(Intensity))) |> 
    dplyr::select(Sample, `Protein IDs`, `Peptide sequences`, Condition, Intensity) 
```

```{r ludovic}
# assign missingness with protti fxn
data_missing <- df_to_protti |>
    assign_missingness(sample=Sample,
                       condition = Condition,
                       grouping = `Protein IDs`,
                       intensity = Intensity,
                       ref_condition = "all")

temp <- df_miss$missingness
temp[which(temp == "all_NA")] <- NA
data_missing$missingness <- temp

# impute data with protti fxn using ludovic method
imputed_ludovic <- impute(
    data_missing,
    sample = Sample,
    grouping = `Protein IDs`,
    intensity_log2 = Intensity,
    condition = Condition,
    comparison = comparison,
    missingness = missingness,
    method = "ludovic",
    skip_log2_transform_error = TRUE
)
rm(data_missing, temp)

# extracting KO and WT
imputed_ludovic <- imputed_ludovic |>
    dplyr::select(Sample, imputed_intensity, `Protein IDs`, missingness) |>
    tidyr::pivot_wider(id_cols = everything(), names_from = Sample, values_from = imputed_intensity)
```

# Number of Missing Values per Condition

```{r rows.to.keep}
tempKO <- apply(lfq[grep("KO", colnames(lfq))], 1, function(row) sum(is.na(row)))
tempWT <- apply(lfq[grep("WT", colnames(lfq))], 1, function(row) sum(is.na(row)))
temp <- cbind.data.frame(KO=tempKO, WT=tempWT)
temp$sum <- temp[,1] + temp[,2]

rows.to.keep <- which((temp[,1] == 3 & temp[,2] == 0) | (temp[,1] == 0 & temp[,2] == 3) |
                      (temp[,1] == 1 & temp[,2] == 0) | (temp[,1] == 0 & temp[,2] == 1) |
                      (temp[,1] == 0 & temp[,2] == 0) | (temp[,1] == 1 & temp[,2] == 1) |
                      (temp[,1] == 2 & temp[,2] == 0) | (temp[,1] == 0 & temp[,2] == 2))

temp <- temp |>
    pivot_longer(cols = 1:2, names_to = "cell", values_to = "no_miss") |>
    mutate(sum = as.factor(sum)) |>
    dplyr::group_by(cell, no_miss, sum) |>
    dplyr::summarise(count = n(), .groups = "drop")

ggplot(data = temp, aes(x = no_miss, y = count, fill=sum)) +
    geom_bar(stat = "identity", position = position_dodge()) + 
    geom_text(aes(label = count), position = position_dodge(width = 0.9),
              vjust = -0.4, size = 3)+
    facet_grid('cell') +
    labs(title="Count of the number of missing values for cell type", 
         xlab="Number of Missing Values per Condition", fill="No. miss.\nper row")
```

```{r clean data}
# Raw Data
lfq <- lfq[rows.to.keep,]

# Extracting only TOTALS data for knockout
LFQ_KO <- lfq |> select(contains("KO"))

# Extracting only TOTALS data for wild type
LFQ_WT <- lfq |> select(contains("WT"))

# Ludovic
imputed_ludovic <- imputed_ludovic[rows.to.keep,]

# extracting KO and WT
LFQ_KO_ludovic <- imputed_ludovic |> select(contains("KO"))
LFQ_WT_ludovic <- imputed_ludovic |> select(contains("WT"))

miss_type <-  data.frame(miss = as.character(imputed_ludovic$missingness),
                         protein.ids = protein.groups$`Protein IDs`[rows.to.keep])
miss_type[is.na(miss_type$miss),1] <- "one_NA"
```

# Distributions

## Ludovic

```{r distribution ludovic}
ggarrange(
    plothist(LFQ_KO, "", FALSE) + xlab("KO") + ggtitle("Non-Imputed"), 
    plothist(LFQ_WT, "", FALSE) + xlab("WT") + ggtitle(""),
    plothist(LFQ_KO_ludovic, "", FALSE) + xlab("KO") + ggtitle("Imputed - Ludovic"), 
    plothist(LFQ_WT_ludovic, "", FALSE) + xlab("WT") + ggtitle(""),
    nrow=2,ncol=2
)
```

# Transformations {.tabset}

## Raw Data

```{r skew raw}
skew <- data.frame(raw_data = moments::skewness(2^lfq,na.rm=T),
                   sqrt = moments::skewness(sqrt(2^lfq),na.rm=T),
                   log = moments::skewness(log(2^lfq),na.rm=T),
                   log10 = moments::skewness(log10(2^lfq),na.rm=T),
                   `frac` = moments::skewness(1/(2^lfq),na.rm=T))
DT::datatable(t(round(skew,4)), options=list(paging=F, info=F, searching=F)) |>
    DT::formatStyle(3, backgroundColor ="lightgreen")
```

## Ludovic

```{r skew ludovic}
skew_ludovic <- data.frame(raw_data = moments::skewness(2^imputed_ludovic[,3:8],na.rm=T),
                   sqrt = moments::skewness(sqrt(2^imputed_ludovic[,3:8]),na.rm=T),
                   log = moments::skewness(log(2^imputed_ludovic[,3:8]),na.rm=T),
                   log10 = moments::skewness(log10(2^imputed_ludovic[,3:8]),na.rm=T),
                   `frac` = moments::skewness(1/(2^imputed_ludovic[,3:8]),na.rm=T))
DT::datatable(t(round(skew_ludovic,4)), options=list(paging=F, info=F, searching=F)) |>
    DT::formatStyle(3, backgroundColor ="lightgreen")
```

# Normalization

## EigenMS

```{r eigen norm, fig.keep="none", results="hide"}
treatment = as.factor(c("KO", "KO", "KO", "WT", "WT", "WT"))

# Non-Imputed
prot.info <- data.frame(prot_ID = paste("prot_", 1:nrow(lfq), sep = "")) # add info about LFQ value
LFQ.eig1 <- eig_norm1(lfq, 
                      treatment = treatment, 
                      prot.info = prot.info)
# Performing eig normalization
LFQ.eig_norm <- eig_norm2(LFQ.eig1)

LFQ_KO.eigen <- LFQ.eig_norm$norm_m[,1:3] # Non-Imputed
eigen_raw_ids <- as.numeric(gsub("prot_", "", rownames(LFQ_KO.eigen)))
temp <- LFQ_KO.eigen
LFQ_KO.eigen <- as.matrix(lfq[,1:3])
LFQ_KO.eigen[eigen_raw_ids,] <- temp

LFQ_WT.eigen <- LFQ.eig_norm$norm_m[,4:6] # Non-Imputed
eigen_raw_ids <- as.numeric(gsub("prot_", "", rownames(LFQ_WT.eigen)))
temp <- LFQ_WT.eigen
LFQ_WT.eigen <- as.matrix(lfq[,4:6])
LFQ_WT.eigen[eigen_raw_ids,] <- temp

# Imputed ludovic
prot.info <- data.frame(imputed_ludovic$`Protein IDs`) # add info about LFQ value
LFQ_ludovic.eig1 <- eig_norm1(imputed_ludovic[,-c(1,2)],
                              treatment = treatment,
                              prot.info = prot.info)
# Performing eig normalization
LFQ_ludovic.eig_norm <- eig_norm2(LFQ_ludovic.eig1)

LFQ_KO_ludovic.eigen <- LFQ_ludovic.eig_norm$norm_m[,1:3] # Imputed ludovic
LFQ_WT_ludovic.eigen <- LFQ_ludovic.eig_norm$norm_m[,4:6] # Imputed ludovic
```

```{r plot dist eigen}
ggarrange(
    plothist(LFQ_KO.eigen, "", FALSE) + xlab("KO") + ggtitle("Non-Imputed"), 
    plothist(LFQ_WT.eigen, "", FALSE) + xlab("WT") + ggtitle(""),
    plothist(LFQ_KO_ludovic.eigen, "", FALSE) + xlab("KO") + ggtitle("Imputed - Ludovic"), 
    plothist(LFQ_WT_ludovic.eigen, "", FALSE) + xlab("WT") + ggtitle(""),
    nrow=2,ncol=2
)
```

# Statistics Metrics {.tabset}

## CV {.tabset}

### Non-Imputed

```{r CV1}
# fxn to calculate the CV coefficient
cv <- function (x) sd(x) / mean(x) * 100

# CV calculation for all normalization methods using non-imputed data
cv.before <- data.frame(KO=apply(2^LFQ_KO, 1, cv), WT=apply(2^LFQ_WT,1,cv))
cv.eig <- data.frame(KO=apply(2^LFQ_KO.eigen, 1, cv), WT=apply(2^LFQ_WT.eigen, 1, cv))

ggarrange(
    plotoneviolin(data.frame(
        Original = cv.before$KO,
        EigenMS = cv.eig$KO
        ), "LFQ CV [%] for KO Samples") + 
        ggplot2::geom_hline(yintercept = c(15,25), linetype=c(2,2), color=c("red","red"), alpha=c(0.7,0.7)),
    plotoneviolin(data.frame(
        Original = cv.before$WT,
        EigenMS = cv.eig$WT
        ), "LFQ CV [%] for WT Samples") + 
        ggplot2::geom_hline(yintercept = c(15,25), linetype=c(2,2), color=c("red","red"), alpha=c(0.7,0.7)),
    nrow=2,ncol=1
)
```

### Ludovic

```{r CV2, fig.width=10}
# CV calculation for all normalization methods with imputed data using ludovic
cv_ludovic.before <- data.frame(KO=apply(2^LFQ_KO_ludovic, 1, cv), WT=apply(2^LFQ_WT_ludovic,1,cv))

cv_ludovic.eig <- data.frame(KO=apply(2^LFQ_KO_ludovic.eigen, 1, cv), WT=apply(2^LFQ_WT_ludovic.eigen, 1, cv))

ggarrange(
    plotoneviolin(data.frame(
        Original = cv_ludovic.before$KO,
        EigenMS = cv_ludovic.eig$KO
        ), "LFQ CV [%] for KO Samples") + 
        ggplot2::geom_hline(yintercept = c(15,25), linetype=c(2,2), color=c("red","red"), alpha=c(0.7,0.7)),
    plotoneviolin(data.frame(
        Original = cv_ludovic.before$WT,
        EigenMS = cv_ludovic.eig$WT
        ), "LFQ CV [%] for WT Samples") + 
        ggplot2::geom_hline(yintercept = c(15,25), linetype=c(2,2), color=c("red","red"), alpha=c(0.7,0.7)),
    nrow=2, ncol=1
)
```

### Summary

```{r cv all}
cv_all <- data.frame(cv.before, cv.eig)
colnames(cv_all) <- c("Before_KO", "Before_WT", "EigenMS_KO", "EigenMS_WT")

cv_ludovic_all <- data.frame(cv_ludovic.before, cv_ludovic.eig)
colnames(cv_ludovic_all) <- c("Before_KO", "Before_WT", "EigenMS_KO", "EigenMS_WT")
```

```{r cv summary}
#### NON-IMPUTED ####
cv_summary_KO <- cv_all |>   # calculating basic statistics for KO
    select(contains("KO")) |>
    pivot_longer(everything(), names_to = "method KO", values_to = "LFQ_CV") |>
    group_by(`method KO`) |>
    summarise("mean_KO"=round(mean(LFQ_CV, na.rm=TRUE),5), 
              "median_KO"=round(median(LFQ_CV, na.rm=TRUE),5), 
              "sd_KO"=round(sd(LFQ_CV, na.rm=TRUE),5))

cv_summary_WT <- cv_all |>   # calculating basic statistics for WT 
    select(contains("WT")) |>
    pivot_longer(everything(), names_to = "method WT", values_to = "LFQ_CV") |>
    group_by(`method WT`) |>
    summarise("mean_WT"=round(mean(LFQ_CV, na.rm=TRUE),5), 
              "median_WT"=round(median(LFQ_CV, na.rm=TRUE),5), 
              "sd_WT"=round(sd(LFQ_CV, na.rm=TRUE),5))

#### LUDOVIC ####
cv_ludovic_summary_KO <- cv_ludovic_all |>   # calculating basic statistics for KO
    select(contains("KO")) |>
    pivot_longer(everything(), names_to = "method KO", values_to = "LFQ_CV") |>
    group_by(`method KO`) |>
    summarise("mean_KO"=round(mean(LFQ_CV, na.rm=TRUE),5), 
              "median_KO"=round(median(LFQ_CV, na.rm=TRUE),5), 
              "sd_KO"=round(sd(LFQ_CV, na.rm=TRUE),5))

cv_ludovic_summary_WT <- cv_ludovic_all |>   # calculating basic statistics for WT
    select(contains("WT")) |>
    pivot_longer(everything(), names_to = "method WT", values_to = "LFQ_CV") |>
    group_by(`method WT`) |>
    summarise("mean_WT"=round(mean(LFQ_CV, na.rm=TRUE),5), 
              "median_WT"=round(median(LFQ_CV, na.rm=TRUE),5), 
              "sd_WT"=round(sd(LFQ_CV, na.rm=TRUE),5))

#### SUMMARY #### 
# prepare more readable output - Non-Ipmuted
cv_summary <- as.data.frame(cbind(cv_summary_KO, cv_summary_WT[-1]))
colnames(cv_summary)[1] <- "method"
cv_summary$method <- gsub("_KO", "", cv_summary$method)

# prepare more readable output - Ludovic
cv_ludovic_summary <- as.data.frame(cbind(cv_ludovic_summary_KO, cv_ludovic_summary_WT[-1]))
colnames(cv_ludovic_summary)[1] <- "method"
cv_ludovic_summary$method <- gsub("_KO", "", cv_ludovic_summary$method)
```

#### Non-Imputed 

```{r cv org summary}
show_cv_table(cv_summary)
```

#### Ludovic

```{r cv lud summary}
show_cv_table(cv_ludovic_summary)
```

## ICC {.tabset}

After normalization, biological replicates should group more tightly. We can 
assess this by measuring the **Intraclass Correlation Coefficient (ICC)** to see if 
replicates cluster together.

A guidelines for interpretation by [Koo and Li (2016)](https://doi.org/10.1016%2Fj.jcm.2016.02.012):

<div style="display: flex;">

<div style="flex: 50%;">
<ul>
<li>below 0.50: poor <span style="color:#D3D3D3;font-size:26px">■</span></li>
<li>between 0.50 and 0.75: moderate <span style="color:#aefda1;font-size:26px">■</span></li>
</ul>
</div>

<div style="flex: 50%;">
<ul>
<li>between 0.75 and 0.90: good <span style="color:#6dff54;font-size:26px">■</span></li>
<li>above 0.90: excellent <span style="color:#1bb400;font-size:26px">■</span></li>
</ul>
</div>

</div>

### Non-Imputed

```{r ICC1}
# Calculate ICC for Non-Imputed KO data
icc.KO.before <- irr::icc(2^LFQ_KO)$value
icc.KO.eig <- irr::icc(2^LFQ_KO.eigen)$value

# Bind all calculated ICCs to a data frame
icc.KO.all <- data.frame(`ICC KO`=c(icc.KO.before,icc.KO.eig))
rownames(icc.KO.all) <- c("Before", "EigenMS")

# Calculate ICC for Non-Imputed WT data
icc.WT.before <- irr::icc(2^LFQ_WT)$value
icc.WT.eig <- irr::icc(2^LFQ_WT.eigen)$value

# Bind all calculated ICCs to a data frame
icc.WT.all <- data.frame(`ICC WT`=c(icc.WT.before,icc.WT.eig))
rownames(icc.WT.all) <- c("Before","EigenMS")

# Show the table in a nice format
DT::datatable(cbind(icc.KO.all, icc.WT.all), 
              options=list(searching=FALSE, paging=FALSE, info=FALSE)) |>
    DT::formatStyle(columns = c("ICC.KO", "ICC.WT"), 
                    background = DT::styleInterval(c(0.5,0.75,0.9), c("#D3D3D3", "#aefda1", "#6dff54", "#1bb400")))
```

### Ludovic

```{r ICC2}
# Calculate ICC for Imputed KO data using ludovic
icc_ludovic.KO.before <- irr::icc(2^LFQ_KO_ludovic)$value
icc_ludovic.KO.eig <- irr::icc(2^LFQ_KO_ludovic.eigen)$value

# Bind all calculated ICCs to a data frame
icc_ludovic.KO.all <- data.frame(`ICC KO`=c(icc_ludovic.KO.before,icc_ludovic.KO.eig))
rownames(icc_ludovic.KO.all) <- c("Before","EigenMS")

# Calculate ICC for Imputed KO data using ludovic
icc_ludovic.WT.before <- irr::icc(2^LFQ_WT_ludovic)$value
icc_ludovic.WT.eig <- irr::icc(2^LFQ_WT_ludovic.eigen)$value

# Bind all calculated ICCs to a data frame
icc_ludovic.WT.all <- data.frame(`ICC WT`=c(icc_ludovic.WT.before,icc_ludovic.WT.eig))
rownames(icc_ludovic.WT.all) <- c("Before","EigenMS")

# Show the table in a nice format
DT::datatable(cbind(icc_ludovic.KO.all, icc_ludovic.WT.all), 
              options=list(searching=FALSE, paging=FALSE, info=FALSE)) |>
    DT::formatStyle(columns = c("ICC.KO", "ICC.WT"), 
                    background = DT::styleInterval(c(0.5,0.75,0.9), c("#D3D3D3", "#aefda1", "#6dff54", "#1bb400")))
```

## t-test 0.05 {.tabset}

In our project we used the paired t-test, which is a test based on the differences
between the values of a single pair, i.e., one deducted from the other. The 
formula for the paired t-test is given by:

$$t = \frac{\sum{d}}{\sqrt{\frac{n(\sum{d^2})-(\sum{d})^2}{n-1}}}$$

Where:

* $d$ is a difference per paired value;
* $n$ is number of samples.

In our calculations, we tested the following hypothesis:

$H_0$: There is no significant difference between the means of the two groups. <br>
$H_1$: There is a significant difference between the two population means.

```{r cutoffs}
p.cutoff = 0.05
FC.cutoff = 1 # set fold change cutoff 
```

### Raw Data

```{r p-value raw data}
# prepare data for t-test
df <- lfq[-which(miss_type$miss == "MNAR"),]

# calculate the p-values for our data
pvalue <- df |>
    dplyr::mutate("p_OCIAD1_TOTALS" = apply(df, 1, ttest, 
                  grp1=grep("KO", colnames(df)), 
                  grp2=grep("WT", colnames(df)))) |>
    dplyr::mutate(significant = ifelse(p_OCIAD1_TOTALS < p.cutoff, TRUE, FALSE),
                  protein.ids = protein.groups$`Protein IDs`[rows.to.keep][-which(miss_type$miss == "MNAR")]) # add a significance column 
m <- mean(pvalue$p_OCIAD1_TOTALS, na.rm=TRUE) # mean of p
me <- median(pvalue$p_OCIAD1_TOTALS, na.rm=TRUE) # median of p

# Plotting the histogram of the p-values filled with a significance info
hist_p <- ggplot(data = pvalue, aes(x = p_OCIAD1_TOTALS, fill=significant)) + 
    geom_histogram(bins = 100) + ggtitle("Non-Imputed - p.value") +
    annotate("text", x = Inf, y = Inf, label = paste("μ(p) =", round(m, 3), "\nmed(p) =", round(me,3)), 
             hjust = 1.1, vjust = 1.3, size = 4, color = "black")
```

```{r p-value ludovic data}
# calculate the p-values for our data
pvalue_ludovic <- imputed_ludovic |>
    dplyr::mutate("p_OCIAD1_TOTALS" = apply(imputed_ludovic, 1, ttest, 
                  grp1=grep("KO", colnames(imputed_ludovic)), 
                  grp2=grep("WT", colnames(imputed_ludovic)))) |>
    dplyr::mutate(significant = ifelse(p_OCIAD1_TOTALS < p.cutoff, TRUE, FALSE),
                  protein.ids = protein.groups$`Protein IDs`[rows.to.keep]) # add a significance column 
m <- mean(pvalue_ludovic$p_OCIAD1_TOTALS, na.rm=TRUE) # mean of p
me <- median(pvalue_ludovic$p_OCIAD1_TOTALS, na.rm=TRUE) # median of p

# Plotting the histogram of the p-values filled with a significance info
hist_p_ludovic <- ggplot(data = pvalue_ludovic, aes(x = p_OCIAD1_TOTALS, fill=significant)) + 
    geom_histogram(bins = 100) + ggtitle("Imputed ludovic - p.value") + theme(legend.position = "none") +
    annotate("text", x = Inf, y = Inf, label = paste("μ(p) =", round(m, 3), "\nmed(p) =", round(me,3)), 
             hjust = 2.1, vjust = 1.3, size = 3.5, color = "black")
```

```{r show raw p-value}
ggarrange(
    hist_p,
    hist_p_ludovic,
    nrow=2
)
```

### EigenMS

```{r p-value raw data eigen}
# prepare data for t-test
eigen_df1 <- cbind.data.frame(LFQ_KO.eigen, LFQ_WT.eigen)
eigen_df <- eigen_df1[-which(miss_type$miss == "MNAR"),]

# calculate the p-values for our data
pvalue_eigen <- eigen_df |>
    dplyr::mutate("p_OCIAD1_TOTALS" = apply(eigen_df, 1, ttest, 
                  grp1=grep("KO", colnames(eigen_df)), 
                  grp2=grep("WT", colnames(eigen_df)))) |>
    dplyr::mutate(significant = ifelse(p_OCIAD1_TOTALS < p.cutoff, TRUE, FALSE),
                  protein.ids = protein.groups$`Protein IDs`[rows.to.keep][-which(miss_type$miss == "MNAR")]) # add a significance column
m <- mean(pvalue_eigen$p_OCIAD1_TOTALS, na.rm=TRUE) # mean of p
me <- median(pvalue_eigen$p_OCIAD1_TOTALS, na.rm=TRUE) # median of p

# Plotting the histogram of the p-values filled with a significance info
hist_p_eigen <- ggplot(data = pvalue_eigen, aes(x = p_OCIAD1_TOTALS, fill=significant)) + 
    geom_histogram(bins = 100) + ggtitle("Non-Imputed - p.value") +
    annotate("text", x = Inf, y = Inf, label = paste("μ(p) =", round(m, 3), "\nmed(p) =", round(me,3)), 
             hjust = 1.1, vjust = 1.3, size = 4, color = "black")
```

```{r p-value ludovic data eigen}
# prepare data for t-test
eigen_df_ludovic <- cbind.data.frame(LFQ_KO_ludovic.eigen, LFQ_WT_ludovic.eigen)

# calculate the p-values for our data
pvalue_eigen_ludovic <- eigen_df_ludovic |>
    dplyr::mutate("p_OCIAD1_TOTALS" = apply(eigen_df_ludovic, 1, ttest, 
                  grp1=grep("KO", colnames(eigen_df_ludovic)), 
                  grp2=grep("WT", colnames(eigen_df_ludovic)))) |>
    dplyr::mutate(significant = ifelse(p_OCIAD1_TOTALS < p.cutoff, TRUE, FALSE),
                  protein.ids = protein.groups$`Protein IDs`[rows.to.keep]) # add a significance column
m <- mean(pvalue_eigen_ludovic$p_OCIAD1_TOTALS, na.rm=TRUE) # mean of p
me <- median(pvalue_eigen_ludovic$p_OCIAD1_TOTALS, na.rm=TRUE) # median of p

# Plotting the histogram of the p-values filled with a significance info
hist_p_eigen_ludovic <- ggplot(data = pvalue_eigen_ludovic, aes(x = p_OCIAD1_TOTALS, fill=significant)) + 
    geom_histogram(bins = 100) + ggtitle("Imputed ludovic - p.value") + theme(legend.position = "none") +
    annotate("text", x = Inf, y = Inf, label = paste("μ(p) =", round(m, 3), "\nmed(p) =", round(me,3)), 
             hjust = 2.1, vjust = 1.3, size = 4, color = "black")
```

```{r show eigen p-value}
ggarrange(
    hist_p_eigen,
    hist_p_eigen_ludovic,
    nrow=2
)
```

# Raw VS Normalized     

```{r prepare data}
# Create a data frame to make interactive plot
data <- data.frame(
    Gene_Name = rep(protein.groups$`Gene names`[rows.to.keep], each=6),
    lfq[,1:6] |> 
        tidyr::pivot_longer(cols=everything(), names_to = "Batch", values_to = "Raw"),
    eigen_df1 |> 
        tidyr::pivot_longer(cols=everything(), names_to = "Batch2", values_to = "Eigen.Raw"),
    imputed_ludovic[,3:8] |> 
        tidyr::pivot_longer(cols=everything(), names_to = "Batch5", values_to = "Ludovic"),
    as_tibble(LFQ_ludovic.eig_norm$norm_m) |> 
        tidyr::pivot_longer(cols=everything(), names_to = "Batch6", values_to = "Eigen.Ludovic")
)|>
    dplyr::select(Gene_Name, Batch, Raw, Eigen.Raw, Ludovic, Eigen.Ludovic)

data[, 3:6][is.na(data[, 3:6])] <- 0
```

<div style="display: flex;">

<div style="flex: 50%;">

```{r input1}
# Define user input from a list of genes
shiny::selectInput("gene", "Select Gene:", choices = unique(data$Gene_Name))
```

</div>

<div style="flex: 50%;">

```{r input2}
# Define the user input of the Y lims
shiny::sliderInput("bottom_y", "Select the bottom level of the Y axis:", 0, 40, 15)
shiny::sliderInput("upper_y", "Select the upper level of the Y axis:", 0, 40, 30)
```

</div>

</div>

```{r interactive bar-plot}
# Creating output with interactive bar plot
output$genePlot <- renderPlotly({
  selected_gene <- input$gene
  bottom_y <- input$bottom_y
  upper_y <- input$upper_y

  # Filter data for selected gene
  filtered_data <- data |>
      dplyr::filter(Gene_Name == selected_gene)
  
  # Create the plot
  plot_ly(data = filtered_data, type = "bar") |>
      add_trace(x = ~Batch, y = ~Raw, name = "Raw") |>
      add_trace(x = ~Batch, y = ~Eigen.Raw, name = "Eigen Raw") |>
      add_trace(x = ~Batch, y = ~Ludovic, name = "Ludovic") |>
      add_trace(x = ~Batch, y = ~Eigen.Ludovic, name = "Eigen Ludovic") |>
      layout(
      title = paste("Bar Plot for Gene:", selected_gene),
      xaxis = list(title = NULL),
      yaxis = list(title = "LFQ Values", range = c(bottom_y,upper_y))
      )
})
```

```{r show bar-plot}
plotlyOutput("genePlot")
```

# Fold Change

<div style="display: flex;">

<div style="flex: 33%;">

```{r input3}
shiny::selectInput("p.cutoff", "Select the p-value cut off:", c(0.05, 0.06))
```

</div>

<div style="flex: 33%;">

```{r input4}
shiny::selectInput("p.type", "Select the type of p-value:", c("p-value", "adj p-value"))
```

</div>

<div style="flex: 33%;">

```{r input5}
shiny::selectInput("adj.method", "Select the p-value adjustment method:", 
                   c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none"))
```

</div>

</div>

## Raw Data {.tabset}

### Non-Imputed

```{r fc raw data}
# Preparing data for calculations
lfq5 <- cbind.data.frame(lfq[-which(miss_type$miss == "MNAR"),], 
                         protein.ids=protein.groups$`Protein IDs`[rows.to.keep][-which(miss_type$miss == "MNAR")],
                         gene = protein.groups$`Gene names`[rows.to.keep][-which(miss_type$miss == "MNAR")])
lfq_long <- lfq5 |>
    tidyr::pivot_longer(1:6, names_to = "sample", values_to = "LFQvalue")

# Add a new column with groups KO or WT
lfq_long$group <- "TOTALS_OCIAD1_KO"
lfq_long$group[grep("WT",lfq_long$sample)] <- "TOTALS_OCIAD1_WT"

# Calculation of means for groups KO and WT
means <- lfq_long |>
    dplyr::group_by(group, protein.ids) |>
    dplyr::summarise(mean=mean(LFQvalue, na.rm=TRUE)) |>
    dplyr::ungroup()

means <- tidyr::pivot_wider(means, names_from = group, values_from = mean) |>
    dplyr::mutate(FC_OCIAD1 = TOTALS_OCIAD1_KO - TOTALS_OCIAD1_WT)

means <- merge(means, miss_type[-which(miss_type$miss == "MNAR"),], by = "protein.ids")

# Preparing data for volcano plot
FC <- merge(means, lfq5, by = "protein.ids")

to_volcano1 <- merge(FC, pvalue, by = "protein.ids")
to_volcano1$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano1$FC_OCIAD1)>FC.cutoff&
                                           to_volcano1$p_OCIAD1_TOTALS<p.cutoff,
                                       yes = TRUE, no = FALSE)
```

```{r v1}
# plotting the volcano plot
output$V1 <- renderPlotly({
    p.cutoff_sel <- as.numeric(input$p.cutoff)
    p.type <- input$p.type
    selected_gene <- input$gene
    adj_method <- input$adj.method
    
    selected_row <- which(to_volcano1$gene == selected_gene)
    if (length(selected_row) != 0) {
        sel_gene_data <- to_volcano1 |> dplyr::filter(gene == selected_gene)
        to_volcano <- to_volcano1[-selected_row,]
    } else {
        to_volcano <- to_volcano1
    }
    
    if (p.type == "adj p-value") {
        to_volcano$p_OCIAD1_TOTALS <- p.adjust(to_volcano$p_OCIAD1_TOTALS, adj_method)
        to_volcano$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_TOTALS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    } else {
        to_volcano$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_TOTALS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    }

    
    # Base plot
    v <- plotly::plot_ly(data = to_volcano, 
                         x = ~FC_OCIAD1, 
                         y = ~-log10(p_OCIAD1_TOTALS), 
                         type = "scatter", 
                         mode = "markers", 
                         color = ~miss, 
                         text = ~gene,
                         symbol = ~sig_TOTALS_OCIAD1,
                         hoverinfo = list("text", "symbol"), # Show label on hover
                         marker = list(size = 5)) |>  # Adjust marker size as needed
        layout(title = paste("Volcano plot for Non-Imputed Data -", p.type),
               xaxis = list(title = "log2(fold change)"),
               yaxis = list(title = paste("-log10(",p.type,")", sep="")),
               shapes = list(
                   list(type = "line", x0 = -1, x1 = -1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_TOTALS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = 1, x1 = 1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_TOTALS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = min(to_volcano$FC_OCIAD1), x1 = max(to_volcano$FC_OCIAD1), 
                        y0 = -log10(p.cutoff_sel), y1 = -log10(p.cutoff_sel),
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7)
               ))
    
    # Add selected genes if any are selected
    if (length(selected_row) != 0) {
        v <- v |> add_markers(data = sel_gene_data, 
                               x = ~FC_OCIAD1, 
                               y = ~-log10(p_OCIAD1_TOTALS), 
                               marker = list(color = "brown", size = 10),
                               inherit = FALSE, # Make sure these points stand out
                               name = selected_gene)  
    }
    
    # Display the plot
    v
})

plotlyOutput("V1")
```

### Ludovic

```{r fc ludovic data}
# Preparing data for calculations
imputed_ludovic <- cbind.data.frame(imputed_ludovic, 
                                    protein.ids=protein.groups$`Protein IDs`[rows.to.keep],
                                    gene = protein.groups$`Gene names`[rows.to.keep])
imputed_long_ludovic <- imputed_ludovic |>
    tidyr::pivot_longer(3:8, names_to = "sample", values_to = "LFQvalue")

# Add a new column with groups KO or WT
imputed_long_ludovic$group <- "TOTALS_OCIAD1_KO"
imputed_long_ludovic$group[grep("WT",imputed_long_ludovic$sample)] <- "TOTALS_OCIAD1_WT"

# Calculation of means for groups KO and WT
means <- imputed_long_ludovic |>
    dplyr::group_by(group, protein.ids) |>
    dplyr::summarise(mean=mean(LFQvalue, na.rm=TRUE)) |>
    dplyr::ungroup()

means <- tidyr::pivot_wider(means, names_from = group, values_from = mean) |>
    dplyr::mutate(FC_OCIAD1 = TOTALS_OCIAD1_KO - TOTALS_OCIAD1_WT)

means <- merge(means, miss_type, by = "protein.ids")

# Preparing data for volcano plot
FC <- merge(means, imputed_ludovic, by = "protein.ids")

to_volcano5 <- merge(FC, pvalue_ludovic, by="Protein IDs")
to_volcano5$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano5$FC_OCIAD1)>FC.cutoff&
                                           to_volcano5$p_OCIAD1_TOTALS<p.cutoff,
                                       yes = TRUE, no = FALSE)
```

```{r v5}
# Plotting the volcano plot
output$V5 <- renderPlotly({
    p.cutoff_sel <- as.numeric(input$p.cutoff)
    p.type <- input$p.type
    selected_gene <- input$gene
    adj_method <- input$adj.method
    
    selected_row <- which(to_volcano5$gene == selected_gene)
    if (length(selected_row) != 0) {
        sel_gene_data <- to_volcano5 |> dplyr::filter(gene == selected_gene)
        to_volcano <- to_volcano5[-selected_row,]
    } else {
        to_volcano <- to_volcano5
    }
    
    if (p.type == "adj p-value") {
        to_volcano$p_OCIAD1_TOTALS <- p.adjust(to_volcano$p_OCIAD1_TOTALS, adj_method)
        to_volcano$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_TOTALS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    } else {
        to_volcano$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_TOTALS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    }
    
    # Base plot
    v <- plotly::plot_ly(data = to_volcano, 
                         x = ~FC_OCIAD1, 
                         y = ~-log10(p_OCIAD1_TOTALS), 
                         type = "scatter", 
                         mode = "markers", 
                         color = ~miss, 
                         text = ~gene,
                         symbol = ~sig_TOTALS_OCIAD1,
                         hoverinfo = list("text", "symbol"),  # Show gene labels on hover
                         marker = list(size = 5)) |>  # Adjust marker size as needed
        layout(title = paste("Volcano plot for Imputed Data Ludovic -", p.type),
               xaxis = list(title = "log2(fold change)"),
               yaxis = list(title = paste("-log10(",p.type,")", sep="")),
               shapes = list(
                   list(type = "line", x0 = -1, x1 = -1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_TOTALS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = 1, x1 = 1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_TOTALS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = min(to_volcano$FC_OCIAD1), x1 = max(to_volcano$FC_OCIAD1), 
                        y0 = -log10(p.cutoff_sel), y1 = -log10(p.cutoff_sel),
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7)
               ))
    
    # Add selected genes if any are selected
    if (length(selected_row) != 0) {
        v <- v |> add_markers(data = sel_gene_data, 
                               x = ~FC_OCIAD1, 
                               y = ~-log10(p_OCIAD1_TOTALS), 
                               marker = list(color = "brown", size = 10),
                               inherit = FALSE, # Make sure these points stand out
                               name = selected_gene) 
    }
    
    # Display the plot
    v
})
plotlyOutput("V5")
```

## EigenMS {.tabset}

### Non-Imputed

```{r fc eigen raw data}
# Preparing data for calculations
eigen_df <- cbind.data.frame(eigen_df1, protein.ids=protein.groups$`Protein IDs`[rows.to.keep],
                             gene = protein.groups$`Gene names`[rows.to.keep])
eigen_df_long <- eigen_df |>
    tidyr::pivot_longer(1:6, names_to = "sample", values_to = "LFQvalue")

# Add a new column with groups KO or WT
eigen_df_long$group <- "TOTALS_OCIAD1_KO"
eigen_df_long$group[grep("WT",eigen_df_long$sample)] <- "TOTALS_OCIAD1_WT"

# Calculation of means for groups KO and WT
means <- eigen_df_long |>
  dplyr::group_by(group, protein.ids) |>
  dplyr::summarise(mean=mean(LFQvalue, na.rm=TRUE)) |>
    dplyr::ungroup()

means <- tidyr::pivot_wider(means, names_from = group, values_from = mean) |>
    dplyr::mutate(FC_OCIAD1 = TOTALS_OCIAD1_KO - TOTALS_OCIAD1_WT)

means <- merge(means, miss_type, by = "protein.ids")

# Preparing data for volcano plot
FC <- merge(means, eigen_df, by = "protein.ids")

to_volcano7 <- merge(FC,pvalue_eigen, by = "protein.ids")
to_volcano7$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano7$FC_OCIAD1)>FC.cutoff&
                                           to_volcano7$p_OCIAD1_TOTALS<p.cutoff,
                                       yes = TRUE, no = FALSE)
```

```{r v1 eigen}
# plotting the volcano plot
output$V1eig <- renderPlotly({
    p.cutoff_sel <- as.numeric(input$p.cutoff)
    p.type <- input$p.type
    selected_gene <- input$gene
    adj_method <- input$adj.method
    
    selected_row <- which(to_volcano7$gene == selected_gene)
    if (length(selected_row) != 0) {
        sel_gene_data <- to_volcano7 |> dplyr::filter(gene == selected_gene)
        to_volcano <- to_volcano7[-selected_row,]
    } else {
        to_volcano <- to_volcano7
    }
    
    if (p.type == "adj p-value") {
        to_volcano$p_OCIAD1_TOTALS <- p.adjust(to_volcano$p_OCIAD1_TOTALS, adj_method)
        to_volcano$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_TOTALS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    } else {
        to_volcano$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_TOTALS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    }
    
    # Base plot
    v <- plotly::plot_ly(data = to_volcano, 
                         x = ~FC_OCIAD1, 
                         y = ~-log10(p_OCIAD1_TOTALS), 
                         type = "scatter", 
                         mode = "markers", 
                         color = ~miss, 
                         text = ~gene,
                         symbol = ~sig_TOTALS_OCIAD1,
                         hoverinfo = list("text", "symbol"),  # Show labels on hover
                         marker = list(size = 5)) |>  # Adjust marker size as needed
        layout(title = paste("Volcano plot for Non-Imputed Data -", p.type),
               xaxis = list(title = "log2(fold change)"),
               yaxis = list(title = paste("-log10(",p.type,")", sep="")),
               shapes = list(
                   list(type = "line", x0 = -1, x1 = -1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_TOTALS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = 1, x1 = 1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_TOTALS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = min(to_volcano$FC_OCIAD1), x1 = max(to_volcano$FC_OCIAD1), 
                        y0 = -log10(p.cutoff_sel), y1 = -log10(p.cutoff_sel),
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7)
               ))
    
    # Add selected genes if any are selected
    if (length(selected_row) != 0) {
        v <- v |> add_markers(data = sel_gene_data, 
                               x = ~FC_OCIAD1, 
                               y = ~-log10(p_OCIAD1_TOTALS), 
                               marker = list(color = "brown", size = 10),
                               inherit = FALSE, # Make sure these points stand out
                               name = selected_gene) 
    }
    
    # Display the plot
    v
})

plotlyOutput("V1eig")
```

### Ludovic

```{r fc eigen ludovic data}
# Preparing data for calculations
eigen_df_ludovic <- cbind.data.frame(eigen_df_ludovic, 
                                     protein.ids=protein.groups$`Protein IDs`[rows.to.keep],
                                     gene = protein.groups$`Gene names`[rows.to.keep])
eigen_df_long_ludovic <- eigen_df_ludovic |>
    tidyr::pivot_longer(1:6, names_to = "sample", values_to = "LFQvalue")

# Add a new column with groups KO or WT
eigen_df_long_ludovic$group <- "TOTALS_OCIAD1_KO"
eigen_df_long_ludovic$group[grep("WT",eigen_df_long_ludovic$sample)] <- "TOTALS_OCIAD1_WT"

# Calculation of means for groups KO and WT
means <- eigen_df_long_ludovic |>
  dplyr::group_by(group, protein.ids) |>
  dplyr::summarise(mean=mean(LFQvalue, na.rm=TRUE)) |>
    dplyr::ungroup()

means <- tidyr::pivot_wider(means, names_from = group, values_from = mean) |>
    dplyr::mutate(FC_OCIAD1 = TOTALS_OCIAD1_KO - TOTALS_OCIAD1_WT)

means <- merge(means, miss_type, by = "protein.ids")

# Preparing data for volcano plot
FC <- merge(means, eigen_df_ludovic, by = "protein.ids")

to_volcano11 <- merge(FC, pvalue_eigen_ludovic, by = "protein.ids")
to_volcano11$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano11$FC_OCIAD1)>FC.cutoff&
                                           to_volcano11$p_OCIAD1_TOTALS<p.cutoff,
                                       yes = TRUE, no = FALSE)
```

```{r v5 eigen}
# Plotting the volcano plot
output$V5eig <- renderPlotly({
    p.cutoff_sel <- as.numeric(input$p.cutoff)
    p.type <- input$p.type
    selected_gene <- input$gene
    adj_method <- input$adj.method
    
    selected_row <- which(to_volcano11$gene == selected_gene)
    if (length(selected_row) != 0) {
        sel_gene_data <- to_volcano11 |> dplyr::filter(gene == selected_gene)
        to_volcano <- to_volcano11[-selected_row,]
    } else {
        to_volcano <- to_volcano11
    }
    
    if (p.type == "adj p-value") {
        to_volcano$p_OCIAD1_TOTALS <- p.adjust(to_volcano$p_OCIAD1_TOTALS, adj_method)
        to_volcano$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_TOTALS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    } else {
        to_volcano$sig_TOTALS_OCIAD1 <- ifelse(abs(to_volcano$FC_OCIAD1)>FC.cutoff &
                                                   to_volcano$p_OCIAD1_TOTALS<p.cutoff_sel,
                                               yes = TRUE, no = FALSE)
    }
    
    # Base plot
    v <- plotly::plot_ly(data = to_volcano, 
                         x = ~FC_OCIAD1, 
                         y = ~-log10(p_OCIAD1_TOTALS), 
                         type = "scatter", 
                         mode = "markers", 
                         color = ~miss, 
                         text = ~gene,
                         symbol = ~sig_TOTALS_OCIAD1,
                         hoverinfo = list("text", "symbol"),  # Show labels on hover
                         marker = list(size = 5)) |>  # Adjust marker size as needed
        layout(title = paste("Volcano plot for Imputed Data Ludovic -", p.type),
               xaxis = list(title = "log2(fold change)"),
               yaxis = list(title = paste("-log10(",p.type,")", sep="")),
               shapes = list(
                   list(type = "line", x0 = -1, x1 = -1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_TOTALS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = 1, x1 = 1, y0 = 0, y1 = max(-log10(to_volcano$p_OCIAD1_TOTALS)), 
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7),
                   list(type = "line", x0 = min(to_volcano$FC_OCIAD1), x1 = max(to_volcano$FC_OCIAD1), 
                        y0 = -log10(p.cutoff_sel), y1 = -log10(p.cutoff_sel),
                        line = list(dash = "dash", width = 1, color = "gray"), opacity = 0.7)
               ))
    
    # Add selected genes if any are selected
    if (length(selected_row) != 0) {
        v <- v |> add_markers(data = sel_gene_data, 
                               x = ~FC_OCIAD1, 
                               y = ~-log10(p_OCIAD1_TOTALS), 
                               marker = list(color = "brown", size = 10),
                               inherit = FALSE, # Make sure these points stand out
                               name = selected_gene) 
    }
    
    # Display the plot
    v
})

plotlyOutput("V5eig")
```

## Table

The table below, show how many proteins are significant and how many are not significant.

```{r}
DT::datatable(
    rbind(Raw = table(to_volcano1$sig_TOTALS_OCIAD1),
          Raw.Eigen = table(to_volcano7$sig_TOTALS_OCIAD1),
          Ludovic = table(to_volcano5$sig_TOTALS_OCIAD1),
          Ludovic.Eigen = table(to_volcano11$sig_TOTALS_OCIAD1)),
    options=list(searching=FALSE, paging=FALSE, info=FALSE))
```

```{r}
protein.groups_ludovic_raw <- protein.groups[rows.to.keep, ]

imputed_ludovic_correct <- data.frame(KO.22=protein.groups_ludovic_raw$`LFQ intensity KO_TOTALS_22`, 
                                      KO.23=protein.groups_ludovic_raw$`LFQ intensity KO_TOTALS_23`,
                                      KO.24=protein.groups_ludovic_raw$`LFQ intensity KO_TOTALS_24`, 
                                      WT.22=protein.groups_ludovic_raw$`LFQ intensity WT_TOTALS_22`, 
                                      WT.23=protein.groups_ludovic_raw$`LFQ intensity WT_TOTALS_23`,
                                      WT.24=protein.groups_ludovic_raw$`LFQ intensity WT_TOTALS_24`)

imputed_ludovic_correct <- imputed_ludovic[,3:8]
protein.groups_ludovic_raw$`LFQ intensity KO_TOTALS_22` <- imputed_ludovic_correct$KO_22
protein.groups_ludovic_raw$`LFQ intensity KO_TOTALS_23` <- imputed_ludovic_correct$KO_23
protein.groups_ludovic_raw$`LFQ intensity KO_TOTALS_24` <- imputed_ludovic_correct$KO_24
protein.groups_ludovic_raw$`LFQ intensity WT_TOTALS_22` <- imputed_ludovic_correct$WT_22
protein.groups_ludovic_raw$`LFQ intensity WT_TOTALS_23` <- imputed_ludovic_correct$WT_23
protein.groups_ludovic_raw$`LFQ intensity WT_TOTALS_24` <- imputed_ludovic_correct$WT_24
protein.groups_ludovic_raw$missingness <- miss_type$miss

protein.groups_ludovic_eigenms <- protein.groups[rows.to.keep,]
eigen_ludovic <- cbind.data.frame(LFQ_KO_ludovic.eigen, LFQ_WT_ludovic.eigen)
eigen_ludovic_clean <- data.frame(KO_22=protein.groups_ludovic_eigenms$`LFQ intensity KO_TOTALS_22`, 
                                  KO_23=protein.groups_ludovic_eigenms$`LFQ intensity KO_TOTALS_23`,
                                  KO_24=protein.groups_ludovic_eigenms$`LFQ intensity KO_TOTALS_24`, 
                                  WT_22=protein.groups_ludovic_eigenms$`LFQ intensity WT_TOTALS_22`, 
                                  WT_23=protein.groups_ludovic_eigenms$`LFQ intensity WT_TOTALS_23`,
                                  WT_24=protein.groups_ludovic_eigenms$`LFQ intensity WT_TOTALS_24`)

eigen_ludovic_clean[,1:6] <- eigen_ludovic

protein.groups_ludovic_eigenms$`LFQ intensity KO_TOTALS_22` <- eigen_ludovic_clean[,1]
protein.groups_ludovic_eigenms$`LFQ intensity KO_TOTALS_23` <- eigen_ludovic_clean[,2]
protein.groups_ludovic_eigenms$`LFQ intensity KO_TOTALS_24` <- eigen_ludovic_clean[,3]
protein.groups_ludovic_eigenms$`LFQ intensity WT_TOTALS_22` <- eigen_ludovic_clean[,4]
protein.groups_ludovic_eigenms$`LFQ intensity WT_TOTALS_23` <- eigen_ludovic_clean[,5]
protein.groups_ludovic_eigenms$`LFQ intensity WT_TOTALS_24` <- eigen_ludovic_clean[,6]
protein.groups_ludovic_eigenms$missingness <- miss_type$miss
```

# Export results

```{r}
write.table(protein.groups_ludovic_raw, file='proteingroups_ludovic_raw_TOTALS.txt', sep='\t', row.names = FALSE)

write.table(protein.groups_ludovic_eigenms, file='proteingroups_ludovic_eigenms_TOTALS.txt', sep='\t', row.name=FALSE)
```